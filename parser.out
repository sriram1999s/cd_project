Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> multiple_statements
Rule 2     multiple_statements -> multiple_statements statement
Rule 3     multiple_statements -> statement
Rule 4     statement -> open
Rule 5     statement -> closed
Rule 6     open -> IF condition statement
Rule 7     open -> IF condition closed ELSE open
Rule 8     open -> WHILE condition open
Rule 9     closed -> simple
Rule 10    closed -> block
Rule 11    closed -> IF condition closed ELSE closed
Rule 12    closed -> WHILE condition closed
Rule 13    condition -> L_PAREN expr R_PAREN
Rule 14    declaration -> TYPE ID SEMICOLON
Rule 15    declaration -> TYPE ID ASSIGN expr SEMICOLON
Rule 16    block -> left_flower multiple_statements right_flower
Rule 17    block -> left_flower right_flower
Rule 18    left_flower -> L_FLOWBRACE
Rule 19    right_flower -> R_FLOWBRACE
Rule 20    simple -> expr SEMICOLON
Rule 21    simple -> header
Rule 22    simple -> declaration
Rule 23    simple -> function
Rule 24    simple -> SEMICOLON
Rule 25    function_call -> ID L_PAREN call_params R_PAREN
Rule 26    call_params -> empty
Rule 27    call_params -> yes_call_params end_call_params
Rule 28    call_params -> end_call_params
Rule 29    yes_call_params -> yes_call_params expr COMMA
Rule 30    yes_call_params -> expr COMMA
Rule 31    end_call_params -> expr
Rule 32    yes_dec_params -> yes_dec_params TYPE expr COMMA
Rule 33    yes_dec_params -> yes_dec_params TYPE COMMA
Rule 34    yes_dec_params -> yes_dec_params TYPE MULTIPLY COMMA
Rule 35    yes_dec_params -> TYPE expr COMMA
Rule 36    yes_dec_params -> TYPE COMMA
Rule 37    yes_dec_params -> TYPE MULTIPLY COMMA
Rule 38    end_dec_params -> TYPE expr
Rule 39    end_dec_params -> TYPE
Rule 40    dec_params -> empty
Rule 41    dec_params -> yes_dec_params end_dec_params
Rule 42    dec_params -> end_dec_params
Rule 43    function -> TYPE ID L_PAREN dec_params R_PAREN function_2
Rule 44    function_2 -> SEMICOLON
Rule 45    function_2 -> block
Rule 46    header -> HASH INCLUDE STRING
Rule 47    header -> HASH INCLUDE HEADER_FILE
Rule 48    empty -> <empty>
Rule 49    expr -> expr assignment exprOR
Rule 50    expr -> exprOR
Rule 51    assignment -> ASSIGN
Rule 52    assignment -> PLUS_ASSIGN
Rule 53    assignment -> MINUS_ASSIGN
Rule 54    assignment -> MUL_ASSIGN
Rule 55    assignment -> DIV_ASSIGN
Rule 56    assignment -> AND_ASSIGN
Rule 57    assignment -> OR_ASSIGN
Rule 58    assignment -> XOR_ASSIGN
Rule 59    assignment -> MOD_ASSIGN
Rule 60    assignment -> L_SHIFT_ASSIGN
Rule 61    assignment -> R_SHIFT_ASSIGN
Rule 62    exprOR -> exprOR OR exprAND
Rule 63    exprOR -> exprAND
Rule 64    exprAND -> exprAND AND exprBITOR
Rule 65    exprAND -> exprBITOR
Rule 66    exprBITOR -> exprBITOR BIT_OR exprBITXOR
Rule 67    exprBITOR -> exprBITXOR
Rule 68    exprBITXOR -> exprBITXOR BIT_XOR exprBITAND
Rule 69    exprBITXOR -> exprBITAND
Rule 70    exprBITAND -> exprBITAND BIT_AND exprEQ
Rule 71    exprBITAND -> exprEQ
Rule 72    exprEQ -> exprEQ EQ exprRELOP
Rule 73    exprEQ -> exprEQ NE exprRELOP
Rule 74    exprEQ -> exprRELOP
Rule 75    exprRELOP -> exprRELOP relop exprSHIFT
Rule 76    exprRELOP -> exprSHIFT
Rule 77    relop -> LE
Rule 78    relop -> LT
Rule 79    relop -> GE
Rule 80    relop -> GT
Rule 81    exprSHIFT -> exprSHIFT L_SHIFT exprOP
Rule 82    exprSHIFT -> exprSHIFT R_SHIFT exprOP
Rule 83    exprSHIFT -> exprOP
Rule 84    exprOP -> exprOP PLUS term
Rule 85    exprOP -> exprOP MINUS term
Rule 86    exprOP -> term
Rule 87    term -> term MULTIPLY factor
Rule 88    term -> term DIVIDE factor
Rule 89    term -> term MOD factor
Rule 90    term -> factor
Rule 91    factor -> NOT factor
Rule 92    factor -> PLUS factor
Rule 93    factor -> MINUS factor
Rule 94    factor -> PLUS_PLUS factor
Rule 95    factor -> MINUS_MINUS factor
Rule 96    factor -> brace
Rule 97    brace -> L_PAREN expr R_PAREN
Rule 98    brace -> brace PLUS_PLUS
Rule 99    brace -> brace MINUS_MINUS
Rule 100   brace -> NUM
Rule 101   brace -> STRING
Rule 102   brace -> ID
Rule 103   brace -> CHAR
Rule 104   brace -> function_call
Rule 105   NUM -> INT_NUM
Rule 106   NUM -> FLOAT_NUM

Terminals, with rules where they appear

AND                  : 64
AND_ASSIGN           : 56
ASSIGN               : 15 51
BIT_AND              : 70
BIT_OR               : 66
BIT_XOR              : 68
CHAR                 : 103
COMMA                : 29 30 32 33 34 35 36 37
DIVIDE               : 88
DIV_ASSIGN           : 55
ELSE                 : 7 11
EQ                   : 72
FLOAT_NUM            : 106
GE                   : 79
GT                   : 80
HASH                 : 46 47
HEADER_FILE          : 47
ID                   : 14 15 25 43 102
IF                   : 6 7 11
INCLUDE              : 46 47
INT_NUM              : 105
LE                   : 77
LT                   : 78
L_FLOWBRACE          : 18
L_PAREN              : 13 25 43 97
L_SHIFT              : 81
L_SHIFT_ASSIGN       : 60
MINUS                : 85 93
MINUS_ASSIGN         : 53
MINUS_MINUS          : 95 99
MOD                  : 89
MOD_ASSIGN           : 59
MULTIPLY             : 34 37 87
MUL_ASSIGN           : 54
NE                   : 73
NOT                  : 91
OR                   : 62
OR_ASSIGN            : 57
PLUS                 : 84 92
PLUS_ASSIGN          : 52
PLUS_PLUS            : 94 98
R_FLOWBRACE          : 19
R_PAREN              : 13 25 43 97
R_SHIFT              : 82
R_SHIFT_ASSIGN       : 61
SEMICOLON            : 14 15 20 24 44
STRING               : 46 101
TYPE                 : 14 15 32 33 34 35 36 37 38 39 43
WHILE                : 8 12
XOR_ASSIGN           : 58
error                : 

Nonterminals, with rules where they appear

NUM                  : 100
assignment           : 49
block                : 10 45
brace                : 96 98 99
call_params          : 25
closed               : 5 7 11 11 12
condition            : 6 7 8 11 12
dec_params           : 43
declaration          : 22
empty                : 26 40
end_call_params      : 27 28
end_dec_params       : 41 42
expr                 : 13 15 20 29 30 31 32 35 38 49 97
exprAND              : 62 63 64
exprBITAND           : 68 69 70
exprBITOR            : 64 65 66
exprBITXOR           : 66 67 68
exprEQ               : 70 71 72 73
exprOP               : 81 82 83 84 85
exprOR               : 49 50 62
exprRELOP            : 72 73 74 75
exprSHIFT            : 75 76 81 82
factor               : 87 88 89 90 91 92 93 94 95
function             : 23
function_2           : 43
function_call        : 104
header               : 21
left_flower          : 16 17
multiple_statements  : 1 2 16
open                 : 4 7 8
relop                : 75
right_flower         : 16 17
simple               : 9
start                : 0
statement            : 2 3 6
term                 : 84 85 86 87 88 89
yes_call_params      : 27 29
yes_dec_params       : 32 33 34 41

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . multiple_statements
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) closed -> . simple
    (10) closed -> . block
    (11) closed -> . IF condition closed ELSE closed
    (12) closed -> . WHILE condition closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . header
    (22) simple -> . declaration
    (23) simple -> . function
    (24) simple -> . SEMICOLON
    (16) block -> . left_flower multiple_statements right_flower
    (17) block -> . left_flower right_flower
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (46) header -> . HASH INCLUDE STRING
    (47) header -> . HASH INCLUDE HEADER_FILE
    (14) declaration -> . TYPE ID SEMICOLON
    (15) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (43) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (18) left_flower -> . L_FLOWBRACE
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    SEMICOLON       shift and go to state 11
    HASH            shift and go to state 17
    TYPE            shift and go to state 19
    L_FLOWBRACE     shift and go to state 22
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    start                          shift and go to state 1
    multiple_statements            shift and go to state 2
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 8
    block                          shift and go to state 9
    expr                           shift and go to state 10
    header                         shift and go to state 12
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    left_flower                    shift and go to state 15
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 1

    (0) S' -> start .



state 2

    (1) start -> multiple_statements .
    (2) multiple_statements -> multiple_statements . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) closed -> . simple
    (10) closed -> . block
    (11) closed -> . IF condition closed ELSE closed
    (12) closed -> . WHILE condition closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . header
    (22) simple -> . declaration
    (23) simple -> . function
    (24) simple -> . SEMICOLON
    (16) block -> . left_flower multiple_statements right_flower
    (17) block -> . left_flower right_flower
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (46) header -> . HASH INCLUDE STRING
    (47) header -> . HASH INCLUDE HEADER_FILE
    (14) declaration -> . TYPE ID SEMICOLON
    (15) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (43) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (18) left_flower -> . L_FLOWBRACE
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    $end            reduce using rule 1 (start -> multiple_statements .)
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    SEMICOLON       shift and go to state 11
    HASH            shift and go to state 17
    TYPE            shift and go to state 19
    L_FLOWBRACE     shift and go to state 22
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    statement                      shift and go to state 44
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 8
    block                          shift and go to state 9
    expr                           shift and go to state 10
    header                         shift and go to state 12
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    left_flower                    shift and go to state 15
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 3

    (3) multiple_statements -> statement .

    IF              reduce using rule 3 (multiple_statements -> statement .)
    WHILE           reduce using rule 3 (multiple_statements -> statement .)
    SEMICOLON       reduce using rule 3 (multiple_statements -> statement .)
    HASH            reduce using rule 3 (multiple_statements -> statement .)
    TYPE            reduce using rule 3 (multiple_statements -> statement .)
    L_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)
    NOT             reduce using rule 3 (multiple_statements -> statement .)
    PLUS            reduce using rule 3 (multiple_statements -> statement .)
    MINUS           reduce using rule 3 (multiple_statements -> statement .)
    PLUS_PLUS       reduce using rule 3 (multiple_statements -> statement .)
    MINUS_MINUS     reduce using rule 3 (multiple_statements -> statement .)
    L_PAREN         reduce using rule 3 (multiple_statements -> statement .)
    STRING          reduce using rule 3 (multiple_statements -> statement .)
    ID              reduce using rule 3 (multiple_statements -> statement .)
    CHAR            reduce using rule 3 (multiple_statements -> statement .)
    INT_NUM         reduce using rule 3 (multiple_statements -> statement .)
    FLOAT_NUM       reduce using rule 3 (multiple_statements -> statement .)
    $end            reduce using rule 3 (multiple_statements -> statement .)
    R_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)


state 4

    (4) statement -> open .

    IF              reduce using rule 4 (statement -> open .)
    WHILE           reduce using rule 4 (statement -> open .)
    SEMICOLON       reduce using rule 4 (statement -> open .)
    HASH            reduce using rule 4 (statement -> open .)
    TYPE            reduce using rule 4 (statement -> open .)
    L_FLOWBRACE     reduce using rule 4 (statement -> open .)
    NOT             reduce using rule 4 (statement -> open .)
    PLUS            reduce using rule 4 (statement -> open .)
    MINUS           reduce using rule 4 (statement -> open .)
    PLUS_PLUS       reduce using rule 4 (statement -> open .)
    MINUS_MINUS     reduce using rule 4 (statement -> open .)
    L_PAREN         reduce using rule 4 (statement -> open .)
    STRING          reduce using rule 4 (statement -> open .)
    ID              reduce using rule 4 (statement -> open .)
    CHAR            reduce using rule 4 (statement -> open .)
    INT_NUM         reduce using rule 4 (statement -> open .)
    FLOAT_NUM       reduce using rule 4 (statement -> open .)
    $end            reduce using rule 4 (statement -> open .)
    R_FLOWBRACE     reduce using rule 4 (statement -> open .)


state 5

    (5) statement -> closed .

    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    HASH            reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    STRING          reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    CHAR            reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 6

    (6) open -> IF . condition statement
    (7) open -> IF . condition closed ELSE open
    (11) closed -> IF . condition closed ELSE closed
    (13) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 46

    condition                      shift and go to state 45

state 7

    (8) open -> WHILE . condition open
    (12) closed -> WHILE . condition closed
    (13) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 46

    condition                      shift and go to state 47

state 8

    (9) closed -> simple .

    IF              reduce using rule 9 (closed -> simple .)
    WHILE           reduce using rule 9 (closed -> simple .)
    SEMICOLON       reduce using rule 9 (closed -> simple .)
    HASH            reduce using rule 9 (closed -> simple .)
    TYPE            reduce using rule 9 (closed -> simple .)
    L_FLOWBRACE     reduce using rule 9 (closed -> simple .)
    NOT             reduce using rule 9 (closed -> simple .)
    PLUS            reduce using rule 9 (closed -> simple .)
    MINUS           reduce using rule 9 (closed -> simple .)
    PLUS_PLUS       reduce using rule 9 (closed -> simple .)
    MINUS_MINUS     reduce using rule 9 (closed -> simple .)
    L_PAREN         reduce using rule 9 (closed -> simple .)
    STRING          reduce using rule 9 (closed -> simple .)
    ID              reduce using rule 9 (closed -> simple .)
    CHAR            reduce using rule 9 (closed -> simple .)
    INT_NUM         reduce using rule 9 (closed -> simple .)
    FLOAT_NUM       reduce using rule 9 (closed -> simple .)
    $end            reduce using rule 9 (closed -> simple .)
    R_FLOWBRACE     reduce using rule 9 (closed -> simple .)
    ELSE            reduce using rule 9 (closed -> simple .)


state 9

    (10) closed -> block .

    IF              reduce using rule 10 (closed -> block .)
    WHILE           reduce using rule 10 (closed -> block .)
    SEMICOLON       reduce using rule 10 (closed -> block .)
    HASH            reduce using rule 10 (closed -> block .)
    TYPE            reduce using rule 10 (closed -> block .)
    L_FLOWBRACE     reduce using rule 10 (closed -> block .)
    NOT             reduce using rule 10 (closed -> block .)
    PLUS            reduce using rule 10 (closed -> block .)
    MINUS           reduce using rule 10 (closed -> block .)
    PLUS_PLUS       reduce using rule 10 (closed -> block .)
    MINUS_MINUS     reduce using rule 10 (closed -> block .)
    L_PAREN         reduce using rule 10 (closed -> block .)
    STRING          reduce using rule 10 (closed -> block .)
    ID              reduce using rule 10 (closed -> block .)
    CHAR            reduce using rule 10 (closed -> block .)
    INT_NUM         reduce using rule 10 (closed -> block .)
    FLOAT_NUM       reduce using rule 10 (closed -> block .)
    $end            reduce using rule 10 (closed -> block .)
    R_FLOWBRACE     reduce using rule 10 (closed -> block .)
    ELSE            reduce using rule 10 (closed -> block .)


state 10

    (20) simple -> expr . SEMICOLON
    (49) expr -> expr . assignment exprOR
    (51) assignment -> . ASSIGN
    (52) assignment -> . PLUS_ASSIGN
    (53) assignment -> . MINUS_ASSIGN
    (54) assignment -> . MUL_ASSIGN
    (55) assignment -> . DIV_ASSIGN
    (56) assignment -> . AND_ASSIGN
    (57) assignment -> . OR_ASSIGN
    (58) assignment -> . XOR_ASSIGN
    (59) assignment -> . MOD_ASSIGN
    (60) assignment -> . L_SHIFT_ASSIGN
    (61) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 48
    ASSIGN          shift and go to state 50
    PLUS_ASSIGN     shift and go to state 51
    MINUS_ASSIGN    shift and go to state 52
    MUL_ASSIGN      shift and go to state 53
    DIV_ASSIGN      shift and go to state 54
    AND_ASSIGN      shift and go to state 55
    OR_ASSIGN       shift and go to state 56
    XOR_ASSIGN      shift and go to state 57
    MOD_ASSIGN      shift and go to state 58
    L_SHIFT_ASSIGN  shift and go to state 59
    R_SHIFT_ASSIGN  shift and go to state 60

    assignment                     shift and go to state 49

state 11

    (24) simple -> SEMICOLON .

    IF              reduce using rule 24 (simple -> SEMICOLON .)
    WHILE           reduce using rule 24 (simple -> SEMICOLON .)
    SEMICOLON       reduce using rule 24 (simple -> SEMICOLON .)
    HASH            reduce using rule 24 (simple -> SEMICOLON .)
    TYPE            reduce using rule 24 (simple -> SEMICOLON .)
    L_FLOWBRACE     reduce using rule 24 (simple -> SEMICOLON .)
    NOT             reduce using rule 24 (simple -> SEMICOLON .)
    PLUS            reduce using rule 24 (simple -> SEMICOLON .)
    MINUS           reduce using rule 24 (simple -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 24 (simple -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 24 (simple -> SEMICOLON .)
    L_PAREN         reduce using rule 24 (simple -> SEMICOLON .)
    STRING          reduce using rule 24 (simple -> SEMICOLON .)
    ID              reduce using rule 24 (simple -> SEMICOLON .)
    CHAR            reduce using rule 24 (simple -> SEMICOLON .)
    INT_NUM         reduce using rule 24 (simple -> SEMICOLON .)
    FLOAT_NUM       reduce using rule 24 (simple -> SEMICOLON .)
    $end            reduce using rule 24 (simple -> SEMICOLON .)
    R_FLOWBRACE     reduce using rule 24 (simple -> SEMICOLON .)
    ELSE            reduce using rule 24 (simple -> SEMICOLON .)


state 12

    (21) simple -> header .

    IF              reduce using rule 21 (simple -> header .)
    WHILE           reduce using rule 21 (simple -> header .)
    SEMICOLON       reduce using rule 21 (simple -> header .)
    HASH            reduce using rule 21 (simple -> header .)
    TYPE            reduce using rule 21 (simple -> header .)
    L_FLOWBRACE     reduce using rule 21 (simple -> header .)
    NOT             reduce using rule 21 (simple -> header .)
    PLUS            reduce using rule 21 (simple -> header .)
    MINUS           reduce using rule 21 (simple -> header .)
    PLUS_PLUS       reduce using rule 21 (simple -> header .)
    MINUS_MINUS     reduce using rule 21 (simple -> header .)
    L_PAREN         reduce using rule 21 (simple -> header .)
    STRING          reduce using rule 21 (simple -> header .)
    ID              reduce using rule 21 (simple -> header .)
    CHAR            reduce using rule 21 (simple -> header .)
    INT_NUM         reduce using rule 21 (simple -> header .)
    FLOAT_NUM       reduce using rule 21 (simple -> header .)
    $end            reduce using rule 21 (simple -> header .)
    R_FLOWBRACE     reduce using rule 21 (simple -> header .)
    ELSE            reduce using rule 21 (simple -> header .)


state 13

    (22) simple -> declaration .

    IF              reduce using rule 22 (simple -> declaration .)
    WHILE           reduce using rule 22 (simple -> declaration .)
    SEMICOLON       reduce using rule 22 (simple -> declaration .)
    HASH            reduce using rule 22 (simple -> declaration .)
    TYPE            reduce using rule 22 (simple -> declaration .)
    L_FLOWBRACE     reduce using rule 22 (simple -> declaration .)
    NOT             reduce using rule 22 (simple -> declaration .)
    PLUS            reduce using rule 22 (simple -> declaration .)
    MINUS           reduce using rule 22 (simple -> declaration .)
    PLUS_PLUS       reduce using rule 22 (simple -> declaration .)
    MINUS_MINUS     reduce using rule 22 (simple -> declaration .)
    L_PAREN         reduce using rule 22 (simple -> declaration .)
    STRING          reduce using rule 22 (simple -> declaration .)
    ID              reduce using rule 22 (simple -> declaration .)
    CHAR            reduce using rule 22 (simple -> declaration .)
    INT_NUM         reduce using rule 22 (simple -> declaration .)
    FLOAT_NUM       reduce using rule 22 (simple -> declaration .)
    $end            reduce using rule 22 (simple -> declaration .)
    R_FLOWBRACE     reduce using rule 22 (simple -> declaration .)
    ELSE            reduce using rule 22 (simple -> declaration .)


state 14

    (23) simple -> function .

    IF              reduce using rule 23 (simple -> function .)
    WHILE           reduce using rule 23 (simple -> function .)
    SEMICOLON       reduce using rule 23 (simple -> function .)
    HASH            reduce using rule 23 (simple -> function .)
    TYPE            reduce using rule 23 (simple -> function .)
    L_FLOWBRACE     reduce using rule 23 (simple -> function .)
    NOT             reduce using rule 23 (simple -> function .)
    PLUS            reduce using rule 23 (simple -> function .)
    MINUS           reduce using rule 23 (simple -> function .)
    PLUS_PLUS       reduce using rule 23 (simple -> function .)
    MINUS_MINUS     reduce using rule 23 (simple -> function .)
    L_PAREN         reduce using rule 23 (simple -> function .)
    STRING          reduce using rule 23 (simple -> function .)
    ID              reduce using rule 23 (simple -> function .)
    CHAR            reduce using rule 23 (simple -> function .)
    INT_NUM         reduce using rule 23 (simple -> function .)
    FLOAT_NUM       reduce using rule 23 (simple -> function .)
    $end            reduce using rule 23 (simple -> function .)
    R_FLOWBRACE     reduce using rule 23 (simple -> function .)
    ELSE            reduce using rule 23 (simple -> function .)


state 15

    (16) block -> left_flower . multiple_statements right_flower
    (17) block -> left_flower . right_flower
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (19) right_flower -> . R_FLOWBRACE
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) closed -> . simple
    (10) closed -> . block
    (11) closed -> . IF condition closed ELSE closed
    (12) closed -> . WHILE condition closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . header
    (22) simple -> . declaration
    (23) simple -> . function
    (24) simple -> . SEMICOLON
    (16) block -> . left_flower multiple_statements right_flower
    (17) block -> . left_flower right_flower
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (46) header -> . HASH INCLUDE STRING
    (47) header -> . HASH INCLUDE HEADER_FILE
    (14) declaration -> . TYPE ID SEMICOLON
    (15) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (43) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (18) left_flower -> . L_FLOWBRACE
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    R_FLOWBRACE     shift and go to state 63
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    SEMICOLON       shift and go to state 11
    HASH            shift and go to state 17
    TYPE            shift and go to state 19
    L_FLOWBRACE     shift and go to state 22
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    left_flower                    shift and go to state 15
    multiple_statements            shift and go to state 61
    right_flower                   shift and go to state 62
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 8
    block                          shift and go to state 9
    expr                           shift and go to state 10
    header                         shift and go to state 12
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 16

    (50) expr -> exprOR .
    (62) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 50 (expr -> exprOR .)
    ASSIGN          reduce using rule 50 (expr -> exprOR .)
    PLUS_ASSIGN     reduce using rule 50 (expr -> exprOR .)
    MINUS_ASSIGN    reduce using rule 50 (expr -> exprOR .)
    MUL_ASSIGN      reduce using rule 50 (expr -> exprOR .)
    DIV_ASSIGN      reduce using rule 50 (expr -> exprOR .)
    AND_ASSIGN      reduce using rule 50 (expr -> exprOR .)
    OR_ASSIGN       reduce using rule 50 (expr -> exprOR .)
    XOR_ASSIGN      reduce using rule 50 (expr -> exprOR .)
    MOD_ASSIGN      reduce using rule 50 (expr -> exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 50 (expr -> exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 50 (expr -> exprOR .)
    R_PAREN         reduce using rule 50 (expr -> exprOR .)
    COMMA           reduce using rule 50 (expr -> exprOR .)
    OR              shift and go to state 64


state 17

    (46) header -> HASH . INCLUDE STRING
    (47) header -> HASH . INCLUDE HEADER_FILE

    INCLUDE         shift and go to state 65


state 18

    (101) brace -> STRING .

    PLUS_PLUS       reduce using rule 101 (brace -> STRING .)
    MINUS_MINUS     reduce using rule 101 (brace -> STRING .)
    MULTIPLY        reduce using rule 101 (brace -> STRING .)
    DIVIDE          reduce using rule 101 (brace -> STRING .)
    MOD             reduce using rule 101 (brace -> STRING .)
    PLUS            reduce using rule 101 (brace -> STRING .)
    MINUS           reduce using rule 101 (brace -> STRING .)
    L_SHIFT         reduce using rule 101 (brace -> STRING .)
    R_SHIFT         reduce using rule 101 (brace -> STRING .)
    LE              reduce using rule 101 (brace -> STRING .)
    LT              reduce using rule 101 (brace -> STRING .)
    GE              reduce using rule 101 (brace -> STRING .)
    GT              reduce using rule 101 (brace -> STRING .)
    EQ              reduce using rule 101 (brace -> STRING .)
    NE              reduce using rule 101 (brace -> STRING .)
    BIT_AND         reduce using rule 101 (brace -> STRING .)
    BIT_XOR         reduce using rule 101 (brace -> STRING .)
    BIT_OR          reduce using rule 101 (brace -> STRING .)
    AND             reduce using rule 101 (brace -> STRING .)
    OR              reduce using rule 101 (brace -> STRING .)
    SEMICOLON       reduce using rule 101 (brace -> STRING .)
    ASSIGN          reduce using rule 101 (brace -> STRING .)
    PLUS_ASSIGN     reduce using rule 101 (brace -> STRING .)
    MINUS_ASSIGN    reduce using rule 101 (brace -> STRING .)
    MUL_ASSIGN      reduce using rule 101 (brace -> STRING .)
    DIV_ASSIGN      reduce using rule 101 (brace -> STRING .)
    AND_ASSIGN      reduce using rule 101 (brace -> STRING .)
    OR_ASSIGN       reduce using rule 101 (brace -> STRING .)
    XOR_ASSIGN      reduce using rule 101 (brace -> STRING .)
    MOD_ASSIGN      reduce using rule 101 (brace -> STRING .)
    L_SHIFT_ASSIGN  reduce using rule 101 (brace -> STRING .)
    R_SHIFT_ASSIGN  reduce using rule 101 (brace -> STRING .)
    R_PAREN         reduce using rule 101 (brace -> STRING .)
    COMMA           reduce using rule 101 (brace -> STRING .)


state 19

    (14) declaration -> TYPE . ID SEMICOLON
    (15) declaration -> TYPE . ID ASSIGN expr SEMICOLON
    (43) function -> TYPE . ID L_PAREN dec_params R_PAREN function_2

    ID              shift and go to state 66


state 20

    (102) brace -> ID .
    (25) function_call -> ID . L_PAREN call_params R_PAREN

    PLUS_PLUS       reduce using rule 102 (brace -> ID .)
    MINUS_MINUS     reduce using rule 102 (brace -> ID .)
    MULTIPLY        reduce using rule 102 (brace -> ID .)
    DIVIDE          reduce using rule 102 (brace -> ID .)
    MOD             reduce using rule 102 (brace -> ID .)
    PLUS            reduce using rule 102 (brace -> ID .)
    MINUS           reduce using rule 102 (brace -> ID .)
    L_SHIFT         reduce using rule 102 (brace -> ID .)
    R_SHIFT         reduce using rule 102 (brace -> ID .)
    LE              reduce using rule 102 (brace -> ID .)
    LT              reduce using rule 102 (brace -> ID .)
    GE              reduce using rule 102 (brace -> ID .)
    GT              reduce using rule 102 (brace -> ID .)
    EQ              reduce using rule 102 (brace -> ID .)
    NE              reduce using rule 102 (brace -> ID .)
    BIT_AND         reduce using rule 102 (brace -> ID .)
    BIT_XOR         reduce using rule 102 (brace -> ID .)
    BIT_OR          reduce using rule 102 (brace -> ID .)
    AND             reduce using rule 102 (brace -> ID .)
    OR              reduce using rule 102 (brace -> ID .)
    SEMICOLON       reduce using rule 102 (brace -> ID .)
    ASSIGN          reduce using rule 102 (brace -> ID .)
    PLUS_ASSIGN     reduce using rule 102 (brace -> ID .)
    MINUS_ASSIGN    reduce using rule 102 (brace -> ID .)
    MUL_ASSIGN      reduce using rule 102 (brace -> ID .)
    DIV_ASSIGN      reduce using rule 102 (brace -> ID .)
    AND_ASSIGN      reduce using rule 102 (brace -> ID .)
    OR_ASSIGN       reduce using rule 102 (brace -> ID .)
    XOR_ASSIGN      reduce using rule 102 (brace -> ID .)
    MOD_ASSIGN      reduce using rule 102 (brace -> ID .)
    L_SHIFT_ASSIGN  reduce using rule 102 (brace -> ID .)
    R_SHIFT_ASSIGN  reduce using rule 102 (brace -> ID .)
    R_PAREN         reduce using rule 102 (brace -> ID .)
    COMMA           reduce using rule 102 (brace -> ID .)
    L_PAREN         shift and go to state 67


state 21

    (97) brace -> L_PAREN . expr R_PAREN
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    expr                           shift and go to state 68
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 22

    (18) left_flower -> L_FLOWBRACE .

    R_FLOWBRACE     reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    IF              reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    WHILE           reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    SEMICOLON       reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    HASH            reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    TYPE            reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    L_FLOWBRACE     reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    NOT             reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    PLUS            reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    MINUS           reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    PLUS_PLUS       reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    MINUS_MINUS     reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    L_PAREN         reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    STRING          reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    ID              reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    CHAR            reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    INT_NUM         reduce using rule 18 (left_flower -> L_FLOWBRACE .)
    FLOAT_NUM       reduce using rule 18 (left_flower -> L_FLOWBRACE .)


state 23

    (63) exprOR -> exprAND .
    (64) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 63 (exprOR -> exprAND .)
    SEMICOLON       reduce using rule 63 (exprOR -> exprAND .)
    ASSIGN          reduce using rule 63 (exprOR -> exprAND .)
    PLUS_ASSIGN     reduce using rule 63 (exprOR -> exprAND .)
    MINUS_ASSIGN    reduce using rule 63 (exprOR -> exprAND .)
    MUL_ASSIGN      reduce using rule 63 (exprOR -> exprAND .)
    DIV_ASSIGN      reduce using rule 63 (exprOR -> exprAND .)
    AND_ASSIGN      reduce using rule 63 (exprOR -> exprAND .)
    OR_ASSIGN       reduce using rule 63 (exprOR -> exprAND .)
    XOR_ASSIGN      reduce using rule 63 (exprOR -> exprAND .)
    MOD_ASSIGN      reduce using rule 63 (exprOR -> exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 63 (exprOR -> exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 63 (exprOR -> exprAND .)
    R_PAREN         reduce using rule 63 (exprOR -> exprAND .)
    COMMA           reduce using rule 63 (exprOR -> exprAND .)
    AND             shift and go to state 69


state 24

    (65) exprAND -> exprBITOR .
    (66) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 65 (exprAND -> exprBITOR .)
    OR              reduce using rule 65 (exprAND -> exprBITOR .)
    SEMICOLON       reduce using rule 65 (exprAND -> exprBITOR .)
    ASSIGN          reduce using rule 65 (exprAND -> exprBITOR .)
    PLUS_ASSIGN     reduce using rule 65 (exprAND -> exprBITOR .)
    MINUS_ASSIGN    reduce using rule 65 (exprAND -> exprBITOR .)
    MUL_ASSIGN      reduce using rule 65 (exprAND -> exprBITOR .)
    DIV_ASSIGN      reduce using rule 65 (exprAND -> exprBITOR .)
    AND_ASSIGN      reduce using rule 65 (exprAND -> exprBITOR .)
    OR_ASSIGN       reduce using rule 65 (exprAND -> exprBITOR .)
    XOR_ASSIGN      reduce using rule 65 (exprAND -> exprBITOR .)
    MOD_ASSIGN      reduce using rule 65 (exprAND -> exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 65 (exprAND -> exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 65 (exprAND -> exprBITOR .)
    R_PAREN         reduce using rule 65 (exprAND -> exprBITOR .)
    COMMA           reduce using rule 65 (exprAND -> exprBITOR .)
    BIT_OR          shift and go to state 70


state 25

    (67) exprBITOR -> exprBITXOR .
    (68) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 67 (exprBITOR -> exprBITXOR .)
    AND             reduce using rule 67 (exprBITOR -> exprBITXOR .)
    OR              reduce using rule 67 (exprBITOR -> exprBITXOR .)
    SEMICOLON       reduce using rule 67 (exprBITOR -> exprBITXOR .)
    ASSIGN          reduce using rule 67 (exprBITOR -> exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 67 (exprBITOR -> exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 67 (exprBITOR -> exprBITXOR .)
    MUL_ASSIGN      reduce using rule 67 (exprBITOR -> exprBITXOR .)
    DIV_ASSIGN      reduce using rule 67 (exprBITOR -> exprBITXOR .)
    AND_ASSIGN      reduce using rule 67 (exprBITOR -> exprBITXOR .)
    OR_ASSIGN       reduce using rule 67 (exprBITOR -> exprBITXOR .)
    XOR_ASSIGN      reduce using rule 67 (exprBITOR -> exprBITXOR .)
    MOD_ASSIGN      reduce using rule 67 (exprBITOR -> exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 67 (exprBITOR -> exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 67 (exprBITOR -> exprBITXOR .)
    R_PAREN         reduce using rule 67 (exprBITOR -> exprBITXOR .)
    COMMA           reduce using rule 67 (exprBITOR -> exprBITXOR .)
    BIT_XOR         shift and go to state 71


state 26

    (69) exprBITXOR -> exprBITAND .
    (70) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 69 (exprBITXOR -> exprBITAND .)
    BIT_OR          reduce using rule 69 (exprBITXOR -> exprBITAND .)
    AND             reduce using rule 69 (exprBITXOR -> exprBITAND .)
    OR              reduce using rule 69 (exprBITXOR -> exprBITAND .)
    SEMICOLON       reduce using rule 69 (exprBITXOR -> exprBITAND .)
    ASSIGN          reduce using rule 69 (exprBITXOR -> exprBITAND .)
    PLUS_ASSIGN     reduce using rule 69 (exprBITXOR -> exprBITAND .)
    MINUS_ASSIGN    reduce using rule 69 (exprBITXOR -> exprBITAND .)
    MUL_ASSIGN      reduce using rule 69 (exprBITXOR -> exprBITAND .)
    DIV_ASSIGN      reduce using rule 69 (exprBITXOR -> exprBITAND .)
    AND_ASSIGN      reduce using rule 69 (exprBITXOR -> exprBITAND .)
    OR_ASSIGN       reduce using rule 69 (exprBITXOR -> exprBITAND .)
    XOR_ASSIGN      reduce using rule 69 (exprBITXOR -> exprBITAND .)
    MOD_ASSIGN      reduce using rule 69 (exprBITXOR -> exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 69 (exprBITXOR -> exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 69 (exprBITXOR -> exprBITAND .)
    R_PAREN         reduce using rule 69 (exprBITXOR -> exprBITAND .)
    COMMA           reduce using rule 69 (exprBITXOR -> exprBITAND .)
    BIT_AND         shift and go to state 72


state 27

    (71) exprBITAND -> exprEQ .
    (72) exprEQ -> exprEQ . EQ exprRELOP
    (73) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 71 (exprBITAND -> exprEQ .)
    BIT_XOR         reduce using rule 71 (exprBITAND -> exprEQ .)
    BIT_OR          reduce using rule 71 (exprBITAND -> exprEQ .)
    AND             reduce using rule 71 (exprBITAND -> exprEQ .)
    OR              reduce using rule 71 (exprBITAND -> exprEQ .)
    SEMICOLON       reduce using rule 71 (exprBITAND -> exprEQ .)
    ASSIGN          reduce using rule 71 (exprBITAND -> exprEQ .)
    PLUS_ASSIGN     reduce using rule 71 (exprBITAND -> exprEQ .)
    MINUS_ASSIGN    reduce using rule 71 (exprBITAND -> exprEQ .)
    MUL_ASSIGN      reduce using rule 71 (exprBITAND -> exprEQ .)
    DIV_ASSIGN      reduce using rule 71 (exprBITAND -> exprEQ .)
    AND_ASSIGN      reduce using rule 71 (exprBITAND -> exprEQ .)
    OR_ASSIGN       reduce using rule 71 (exprBITAND -> exprEQ .)
    XOR_ASSIGN      reduce using rule 71 (exprBITAND -> exprEQ .)
    MOD_ASSIGN      reduce using rule 71 (exprBITAND -> exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 71 (exprBITAND -> exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 71 (exprBITAND -> exprEQ .)
    R_PAREN         reduce using rule 71 (exprBITAND -> exprEQ .)
    COMMA           reduce using rule 71 (exprBITAND -> exprEQ .)
    EQ              shift and go to state 73
    NE              shift and go to state 74


state 28

    (74) exprEQ -> exprRELOP .
    (75) exprRELOP -> exprRELOP . relop exprSHIFT
    (77) relop -> . LE
    (78) relop -> . LT
    (79) relop -> . GE
    (80) relop -> . GT

    EQ              reduce using rule 74 (exprEQ -> exprRELOP .)
    NE              reduce using rule 74 (exprEQ -> exprRELOP .)
    BIT_AND         reduce using rule 74 (exprEQ -> exprRELOP .)
    BIT_XOR         reduce using rule 74 (exprEQ -> exprRELOP .)
    BIT_OR          reduce using rule 74 (exprEQ -> exprRELOP .)
    AND             reduce using rule 74 (exprEQ -> exprRELOP .)
    OR              reduce using rule 74 (exprEQ -> exprRELOP .)
    SEMICOLON       reduce using rule 74 (exprEQ -> exprRELOP .)
    ASSIGN          reduce using rule 74 (exprEQ -> exprRELOP .)
    PLUS_ASSIGN     reduce using rule 74 (exprEQ -> exprRELOP .)
    MINUS_ASSIGN    reduce using rule 74 (exprEQ -> exprRELOP .)
    MUL_ASSIGN      reduce using rule 74 (exprEQ -> exprRELOP .)
    DIV_ASSIGN      reduce using rule 74 (exprEQ -> exprRELOP .)
    AND_ASSIGN      reduce using rule 74 (exprEQ -> exprRELOP .)
    OR_ASSIGN       reduce using rule 74 (exprEQ -> exprRELOP .)
    XOR_ASSIGN      reduce using rule 74 (exprEQ -> exprRELOP .)
    MOD_ASSIGN      reduce using rule 74 (exprEQ -> exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 74 (exprEQ -> exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 74 (exprEQ -> exprRELOP .)
    R_PAREN         reduce using rule 74 (exprEQ -> exprRELOP .)
    COMMA           reduce using rule 74 (exprEQ -> exprRELOP .)
    LE              shift and go to state 76
    LT              shift and go to state 77
    GE              shift and go to state 78
    GT              shift and go to state 79

    relop                          shift and go to state 75

state 29

    (76) exprRELOP -> exprSHIFT .
    (81) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (82) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 76 (exprRELOP -> exprSHIFT .)
    LT              reduce using rule 76 (exprRELOP -> exprSHIFT .)
    GE              reduce using rule 76 (exprRELOP -> exprSHIFT .)
    GT              reduce using rule 76 (exprRELOP -> exprSHIFT .)
    EQ              reduce using rule 76 (exprRELOP -> exprSHIFT .)
    NE              reduce using rule 76 (exprRELOP -> exprSHIFT .)
    BIT_AND         reduce using rule 76 (exprRELOP -> exprSHIFT .)
    BIT_XOR         reduce using rule 76 (exprRELOP -> exprSHIFT .)
    BIT_OR          reduce using rule 76 (exprRELOP -> exprSHIFT .)
    AND             reduce using rule 76 (exprRELOP -> exprSHIFT .)
    OR              reduce using rule 76 (exprRELOP -> exprSHIFT .)
    SEMICOLON       reduce using rule 76 (exprRELOP -> exprSHIFT .)
    ASSIGN          reduce using rule 76 (exprRELOP -> exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 76 (exprRELOP -> exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 76 (exprRELOP -> exprSHIFT .)
    MUL_ASSIGN      reduce using rule 76 (exprRELOP -> exprSHIFT .)
    DIV_ASSIGN      reduce using rule 76 (exprRELOP -> exprSHIFT .)
    AND_ASSIGN      reduce using rule 76 (exprRELOP -> exprSHIFT .)
    OR_ASSIGN       reduce using rule 76 (exprRELOP -> exprSHIFT .)
    XOR_ASSIGN      reduce using rule 76 (exprRELOP -> exprSHIFT .)
    MOD_ASSIGN      reduce using rule 76 (exprRELOP -> exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 76 (exprRELOP -> exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 76 (exprRELOP -> exprSHIFT .)
    R_PAREN         reduce using rule 76 (exprRELOP -> exprSHIFT .)
    COMMA           reduce using rule 76 (exprRELOP -> exprSHIFT .)
    L_SHIFT         shift and go to state 80
    R_SHIFT         shift and go to state 81


state 30

    (83) exprSHIFT -> exprOP .
    (84) exprOP -> exprOP . PLUS term
    (85) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 83 (exprSHIFT -> exprOP .)
    R_SHIFT         reduce using rule 83 (exprSHIFT -> exprOP .)
    LE              reduce using rule 83 (exprSHIFT -> exprOP .)
    LT              reduce using rule 83 (exprSHIFT -> exprOP .)
    GE              reduce using rule 83 (exprSHIFT -> exprOP .)
    GT              reduce using rule 83 (exprSHIFT -> exprOP .)
    EQ              reduce using rule 83 (exprSHIFT -> exprOP .)
    NE              reduce using rule 83 (exprSHIFT -> exprOP .)
    BIT_AND         reduce using rule 83 (exprSHIFT -> exprOP .)
    BIT_XOR         reduce using rule 83 (exprSHIFT -> exprOP .)
    BIT_OR          reduce using rule 83 (exprSHIFT -> exprOP .)
    AND             reduce using rule 83 (exprSHIFT -> exprOP .)
    OR              reduce using rule 83 (exprSHIFT -> exprOP .)
    SEMICOLON       reduce using rule 83 (exprSHIFT -> exprOP .)
    ASSIGN          reduce using rule 83 (exprSHIFT -> exprOP .)
    PLUS_ASSIGN     reduce using rule 83 (exprSHIFT -> exprOP .)
    MINUS_ASSIGN    reduce using rule 83 (exprSHIFT -> exprOP .)
    MUL_ASSIGN      reduce using rule 83 (exprSHIFT -> exprOP .)
    DIV_ASSIGN      reduce using rule 83 (exprSHIFT -> exprOP .)
    AND_ASSIGN      reduce using rule 83 (exprSHIFT -> exprOP .)
    OR_ASSIGN       reduce using rule 83 (exprSHIFT -> exprOP .)
    XOR_ASSIGN      reduce using rule 83 (exprSHIFT -> exprOP .)
    MOD_ASSIGN      reduce using rule 83 (exprSHIFT -> exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 83 (exprSHIFT -> exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 83 (exprSHIFT -> exprOP .)
    R_PAREN         reduce using rule 83 (exprSHIFT -> exprOP .)
    COMMA           reduce using rule 83 (exprSHIFT -> exprOP .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 31

    (92) factor -> PLUS . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    factor                         shift and go to state 84
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 32

    (86) exprOP -> term .
    (87) term -> term . MULTIPLY factor
    (88) term -> term . DIVIDE factor
    (89) term -> term . MOD factor

    PLUS            reduce using rule 86 (exprOP -> term .)
    MINUS           reduce using rule 86 (exprOP -> term .)
    L_SHIFT         reduce using rule 86 (exprOP -> term .)
    R_SHIFT         reduce using rule 86 (exprOP -> term .)
    LE              reduce using rule 86 (exprOP -> term .)
    LT              reduce using rule 86 (exprOP -> term .)
    GE              reduce using rule 86 (exprOP -> term .)
    GT              reduce using rule 86 (exprOP -> term .)
    EQ              reduce using rule 86 (exprOP -> term .)
    NE              reduce using rule 86 (exprOP -> term .)
    BIT_AND         reduce using rule 86 (exprOP -> term .)
    BIT_XOR         reduce using rule 86 (exprOP -> term .)
    BIT_OR          reduce using rule 86 (exprOP -> term .)
    AND             reduce using rule 86 (exprOP -> term .)
    OR              reduce using rule 86 (exprOP -> term .)
    SEMICOLON       reduce using rule 86 (exprOP -> term .)
    ASSIGN          reduce using rule 86 (exprOP -> term .)
    PLUS_ASSIGN     reduce using rule 86 (exprOP -> term .)
    MINUS_ASSIGN    reduce using rule 86 (exprOP -> term .)
    MUL_ASSIGN      reduce using rule 86 (exprOP -> term .)
    DIV_ASSIGN      reduce using rule 86 (exprOP -> term .)
    AND_ASSIGN      reduce using rule 86 (exprOP -> term .)
    OR_ASSIGN       reduce using rule 86 (exprOP -> term .)
    XOR_ASSIGN      reduce using rule 86 (exprOP -> term .)
    MOD_ASSIGN      reduce using rule 86 (exprOP -> term .)
    L_SHIFT_ASSIGN  reduce using rule 86 (exprOP -> term .)
    R_SHIFT_ASSIGN  reduce using rule 86 (exprOP -> term .)
    R_PAREN         reduce using rule 86 (exprOP -> term .)
    COMMA           reduce using rule 86 (exprOP -> term .)
    MULTIPLY        shift and go to state 85
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 87


state 33

    (93) factor -> MINUS . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    factor                         shift and go to state 88
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 34

    (90) term -> factor .

    MULTIPLY        reduce using rule 90 (term -> factor .)
    DIVIDE          reduce using rule 90 (term -> factor .)
    MOD             reduce using rule 90 (term -> factor .)
    PLUS            reduce using rule 90 (term -> factor .)
    MINUS           reduce using rule 90 (term -> factor .)
    L_SHIFT         reduce using rule 90 (term -> factor .)
    R_SHIFT         reduce using rule 90 (term -> factor .)
    LE              reduce using rule 90 (term -> factor .)
    LT              reduce using rule 90 (term -> factor .)
    GE              reduce using rule 90 (term -> factor .)
    GT              reduce using rule 90 (term -> factor .)
    EQ              reduce using rule 90 (term -> factor .)
    NE              reduce using rule 90 (term -> factor .)
    BIT_AND         reduce using rule 90 (term -> factor .)
    BIT_XOR         reduce using rule 90 (term -> factor .)
    BIT_OR          reduce using rule 90 (term -> factor .)
    AND             reduce using rule 90 (term -> factor .)
    OR              reduce using rule 90 (term -> factor .)
    SEMICOLON       reduce using rule 90 (term -> factor .)
    ASSIGN          reduce using rule 90 (term -> factor .)
    PLUS_ASSIGN     reduce using rule 90 (term -> factor .)
    MINUS_ASSIGN    reduce using rule 90 (term -> factor .)
    MUL_ASSIGN      reduce using rule 90 (term -> factor .)
    DIV_ASSIGN      reduce using rule 90 (term -> factor .)
    AND_ASSIGN      reduce using rule 90 (term -> factor .)
    OR_ASSIGN       reduce using rule 90 (term -> factor .)
    XOR_ASSIGN      reduce using rule 90 (term -> factor .)
    MOD_ASSIGN      reduce using rule 90 (term -> factor .)
    L_SHIFT_ASSIGN  reduce using rule 90 (term -> factor .)
    R_SHIFT_ASSIGN  reduce using rule 90 (term -> factor .)
    R_PAREN         reduce using rule 90 (term -> factor .)
    COMMA           reduce using rule 90 (term -> factor .)


state 35

    (91) factor -> NOT . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    factor                         shift and go to state 89
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 36

    (94) factor -> PLUS_PLUS . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    factor                         shift and go to state 90
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 37

    (95) factor -> MINUS_MINUS . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    factor                         shift and go to state 91
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 38

    (96) factor -> brace .
    (98) brace -> brace . PLUS_PLUS
    (99) brace -> brace . MINUS_MINUS

    MULTIPLY        reduce using rule 96 (factor -> brace .)
    DIVIDE          reduce using rule 96 (factor -> brace .)
    MOD             reduce using rule 96 (factor -> brace .)
    PLUS            reduce using rule 96 (factor -> brace .)
    MINUS           reduce using rule 96 (factor -> brace .)
    L_SHIFT         reduce using rule 96 (factor -> brace .)
    R_SHIFT         reduce using rule 96 (factor -> brace .)
    LE              reduce using rule 96 (factor -> brace .)
    LT              reduce using rule 96 (factor -> brace .)
    GE              reduce using rule 96 (factor -> brace .)
    GT              reduce using rule 96 (factor -> brace .)
    EQ              reduce using rule 96 (factor -> brace .)
    NE              reduce using rule 96 (factor -> brace .)
    BIT_AND         reduce using rule 96 (factor -> brace .)
    BIT_XOR         reduce using rule 96 (factor -> brace .)
    BIT_OR          reduce using rule 96 (factor -> brace .)
    AND             reduce using rule 96 (factor -> brace .)
    OR              reduce using rule 96 (factor -> brace .)
    SEMICOLON       reduce using rule 96 (factor -> brace .)
    ASSIGN          reduce using rule 96 (factor -> brace .)
    PLUS_ASSIGN     reduce using rule 96 (factor -> brace .)
    MINUS_ASSIGN    reduce using rule 96 (factor -> brace .)
    MUL_ASSIGN      reduce using rule 96 (factor -> brace .)
    DIV_ASSIGN      reduce using rule 96 (factor -> brace .)
    AND_ASSIGN      reduce using rule 96 (factor -> brace .)
    OR_ASSIGN       reduce using rule 96 (factor -> brace .)
    XOR_ASSIGN      reduce using rule 96 (factor -> brace .)
    MOD_ASSIGN      reduce using rule 96 (factor -> brace .)
    L_SHIFT_ASSIGN  reduce using rule 96 (factor -> brace .)
    R_SHIFT_ASSIGN  reduce using rule 96 (factor -> brace .)
    R_PAREN         reduce using rule 96 (factor -> brace .)
    COMMA           reduce using rule 96 (factor -> brace .)
    PLUS_PLUS       shift and go to state 92
    MINUS_MINUS     shift and go to state 93


state 39

    (100) brace -> NUM .

    PLUS_PLUS       reduce using rule 100 (brace -> NUM .)
    MINUS_MINUS     reduce using rule 100 (brace -> NUM .)
    MULTIPLY        reduce using rule 100 (brace -> NUM .)
    DIVIDE          reduce using rule 100 (brace -> NUM .)
    MOD             reduce using rule 100 (brace -> NUM .)
    PLUS            reduce using rule 100 (brace -> NUM .)
    MINUS           reduce using rule 100 (brace -> NUM .)
    L_SHIFT         reduce using rule 100 (brace -> NUM .)
    R_SHIFT         reduce using rule 100 (brace -> NUM .)
    LE              reduce using rule 100 (brace -> NUM .)
    LT              reduce using rule 100 (brace -> NUM .)
    GE              reduce using rule 100 (brace -> NUM .)
    GT              reduce using rule 100 (brace -> NUM .)
    EQ              reduce using rule 100 (brace -> NUM .)
    NE              reduce using rule 100 (brace -> NUM .)
    BIT_AND         reduce using rule 100 (brace -> NUM .)
    BIT_XOR         reduce using rule 100 (brace -> NUM .)
    BIT_OR          reduce using rule 100 (brace -> NUM .)
    AND             reduce using rule 100 (brace -> NUM .)
    OR              reduce using rule 100 (brace -> NUM .)
    SEMICOLON       reduce using rule 100 (brace -> NUM .)
    ASSIGN          reduce using rule 100 (brace -> NUM .)
    PLUS_ASSIGN     reduce using rule 100 (brace -> NUM .)
    MINUS_ASSIGN    reduce using rule 100 (brace -> NUM .)
    MUL_ASSIGN      reduce using rule 100 (brace -> NUM .)
    DIV_ASSIGN      reduce using rule 100 (brace -> NUM .)
    AND_ASSIGN      reduce using rule 100 (brace -> NUM .)
    OR_ASSIGN       reduce using rule 100 (brace -> NUM .)
    XOR_ASSIGN      reduce using rule 100 (brace -> NUM .)
    MOD_ASSIGN      reduce using rule 100 (brace -> NUM .)
    L_SHIFT_ASSIGN  reduce using rule 100 (brace -> NUM .)
    R_SHIFT_ASSIGN  reduce using rule 100 (brace -> NUM .)
    R_PAREN         reduce using rule 100 (brace -> NUM .)
    COMMA           reduce using rule 100 (brace -> NUM .)


state 40

    (103) brace -> CHAR .

    PLUS_PLUS       reduce using rule 103 (brace -> CHAR .)
    MINUS_MINUS     reduce using rule 103 (brace -> CHAR .)
    MULTIPLY        reduce using rule 103 (brace -> CHAR .)
    DIVIDE          reduce using rule 103 (brace -> CHAR .)
    MOD             reduce using rule 103 (brace -> CHAR .)
    PLUS            reduce using rule 103 (brace -> CHAR .)
    MINUS           reduce using rule 103 (brace -> CHAR .)
    L_SHIFT         reduce using rule 103 (brace -> CHAR .)
    R_SHIFT         reduce using rule 103 (brace -> CHAR .)
    LE              reduce using rule 103 (brace -> CHAR .)
    LT              reduce using rule 103 (brace -> CHAR .)
    GE              reduce using rule 103 (brace -> CHAR .)
    GT              reduce using rule 103 (brace -> CHAR .)
    EQ              reduce using rule 103 (brace -> CHAR .)
    NE              reduce using rule 103 (brace -> CHAR .)
    BIT_AND         reduce using rule 103 (brace -> CHAR .)
    BIT_XOR         reduce using rule 103 (brace -> CHAR .)
    BIT_OR          reduce using rule 103 (brace -> CHAR .)
    AND             reduce using rule 103 (brace -> CHAR .)
    OR              reduce using rule 103 (brace -> CHAR .)
    SEMICOLON       reduce using rule 103 (brace -> CHAR .)
    ASSIGN          reduce using rule 103 (brace -> CHAR .)
    PLUS_ASSIGN     reduce using rule 103 (brace -> CHAR .)
    MINUS_ASSIGN    reduce using rule 103 (brace -> CHAR .)
    MUL_ASSIGN      reduce using rule 103 (brace -> CHAR .)
    DIV_ASSIGN      reduce using rule 103 (brace -> CHAR .)
    AND_ASSIGN      reduce using rule 103 (brace -> CHAR .)
    OR_ASSIGN       reduce using rule 103 (brace -> CHAR .)
    XOR_ASSIGN      reduce using rule 103 (brace -> CHAR .)
    MOD_ASSIGN      reduce using rule 103 (brace -> CHAR .)
    L_SHIFT_ASSIGN  reduce using rule 103 (brace -> CHAR .)
    R_SHIFT_ASSIGN  reduce using rule 103 (brace -> CHAR .)
    R_PAREN         reduce using rule 103 (brace -> CHAR .)
    COMMA           reduce using rule 103 (brace -> CHAR .)


state 41

    (104) brace -> function_call .

    PLUS_PLUS       reduce using rule 104 (brace -> function_call .)
    MINUS_MINUS     reduce using rule 104 (brace -> function_call .)
    MULTIPLY        reduce using rule 104 (brace -> function_call .)
    DIVIDE          reduce using rule 104 (brace -> function_call .)
    MOD             reduce using rule 104 (brace -> function_call .)
    PLUS            reduce using rule 104 (brace -> function_call .)
    MINUS           reduce using rule 104 (brace -> function_call .)
    L_SHIFT         reduce using rule 104 (brace -> function_call .)
    R_SHIFT         reduce using rule 104 (brace -> function_call .)
    LE              reduce using rule 104 (brace -> function_call .)
    LT              reduce using rule 104 (brace -> function_call .)
    GE              reduce using rule 104 (brace -> function_call .)
    GT              reduce using rule 104 (brace -> function_call .)
    EQ              reduce using rule 104 (brace -> function_call .)
    NE              reduce using rule 104 (brace -> function_call .)
    BIT_AND         reduce using rule 104 (brace -> function_call .)
    BIT_XOR         reduce using rule 104 (brace -> function_call .)
    BIT_OR          reduce using rule 104 (brace -> function_call .)
    AND             reduce using rule 104 (brace -> function_call .)
    OR              reduce using rule 104 (brace -> function_call .)
    SEMICOLON       reduce using rule 104 (brace -> function_call .)
    ASSIGN          reduce using rule 104 (brace -> function_call .)
    PLUS_ASSIGN     reduce using rule 104 (brace -> function_call .)
    MINUS_ASSIGN    reduce using rule 104 (brace -> function_call .)
    MUL_ASSIGN      reduce using rule 104 (brace -> function_call .)
    DIV_ASSIGN      reduce using rule 104 (brace -> function_call .)
    AND_ASSIGN      reduce using rule 104 (brace -> function_call .)
    OR_ASSIGN       reduce using rule 104 (brace -> function_call .)
    XOR_ASSIGN      reduce using rule 104 (brace -> function_call .)
    MOD_ASSIGN      reduce using rule 104 (brace -> function_call .)
    L_SHIFT_ASSIGN  reduce using rule 104 (brace -> function_call .)
    R_SHIFT_ASSIGN  reduce using rule 104 (brace -> function_call .)
    R_PAREN         reduce using rule 104 (brace -> function_call .)
    COMMA           reduce using rule 104 (brace -> function_call .)


state 42

    (105) NUM -> INT_NUM .

    PLUS_PLUS       reduce using rule 105 (NUM -> INT_NUM .)
    MINUS_MINUS     reduce using rule 105 (NUM -> INT_NUM .)
    MULTIPLY        reduce using rule 105 (NUM -> INT_NUM .)
    DIVIDE          reduce using rule 105 (NUM -> INT_NUM .)
    MOD             reduce using rule 105 (NUM -> INT_NUM .)
    PLUS            reduce using rule 105 (NUM -> INT_NUM .)
    MINUS           reduce using rule 105 (NUM -> INT_NUM .)
    L_SHIFT         reduce using rule 105 (NUM -> INT_NUM .)
    R_SHIFT         reduce using rule 105 (NUM -> INT_NUM .)
    LE              reduce using rule 105 (NUM -> INT_NUM .)
    LT              reduce using rule 105 (NUM -> INT_NUM .)
    GE              reduce using rule 105 (NUM -> INT_NUM .)
    GT              reduce using rule 105 (NUM -> INT_NUM .)
    EQ              reduce using rule 105 (NUM -> INT_NUM .)
    NE              reduce using rule 105 (NUM -> INT_NUM .)
    BIT_AND         reduce using rule 105 (NUM -> INT_NUM .)
    BIT_XOR         reduce using rule 105 (NUM -> INT_NUM .)
    BIT_OR          reduce using rule 105 (NUM -> INT_NUM .)
    AND             reduce using rule 105 (NUM -> INT_NUM .)
    OR              reduce using rule 105 (NUM -> INT_NUM .)
    SEMICOLON       reduce using rule 105 (NUM -> INT_NUM .)
    ASSIGN          reduce using rule 105 (NUM -> INT_NUM .)
    PLUS_ASSIGN     reduce using rule 105 (NUM -> INT_NUM .)
    MINUS_ASSIGN    reduce using rule 105 (NUM -> INT_NUM .)
    MUL_ASSIGN      reduce using rule 105 (NUM -> INT_NUM .)
    DIV_ASSIGN      reduce using rule 105 (NUM -> INT_NUM .)
    AND_ASSIGN      reduce using rule 105 (NUM -> INT_NUM .)
    OR_ASSIGN       reduce using rule 105 (NUM -> INT_NUM .)
    XOR_ASSIGN      reduce using rule 105 (NUM -> INT_NUM .)
    MOD_ASSIGN      reduce using rule 105 (NUM -> INT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 105 (NUM -> INT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 105 (NUM -> INT_NUM .)
    R_PAREN         reduce using rule 105 (NUM -> INT_NUM .)
    COMMA           reduce using rule 105 (NUM -> INT_NUM .)


state 43

    (106) NUM -> FLOAT_NUM .

    PLUS_PLUS       reduce using rule 106 (NUM -> FLOAT_NUM .)
    MINUS_MINUS     reduce using rule 106 (NUM -> FLOAT_NUM .)
    MULTIPLY        reduce using rule 106 (NUM -> FLOAT_NUM .)
    DIVIDE          reduce using rule 106 (NUM -> FLOAT_NUM .)
    MOD             reduce using rule 106 (NUM -> FLOAT_NUM .)
    PLUS            reduce using rule 106 (NUM -> FLOAT_NUM .)
    MINUS           reduce using rule 106 (NUM -> FLOAT_NUM .)
    L_SHIFT         reduce using rule 106 (NUM -> FLOAT_NUM .)
    R_SHIFT         reduce using rule 106 (NUM -> FLOAT_NUM .)
    LE              reduce using rule 106 (NUM -> FLOAT_NUM .)
    LT              reduce using rule 106 (NUM -> FLOAT_NUM .)
    GE              reduce using rule 106 (NUM -> FLOAT_NUM .)
    GT              reduce using rule 106 (NUM -> FLOAT_NUM .)
    EQ              reduce using rule 106 (NUM -> FLOAT_NUM .)
    NE              reduce using rule 106 (NUM -> FLOAT_NUM .)
    BIT_AND         reduce using rule 106 (NUM -> FLOAT_NUM .)
    BIT_XOR         reduce using rule 106 (NUM -> FLOAT_NUM .)
    BIT_OR          reduce using rule 106 (NUM -> FLOAT_NUM .)
    AND             reduce using rule 106 (NUM -> FLOAT_NUM .)
    OR              reduce using rule 106 (NUM -> FLOAT_NUM .)
    SEMICOLON       reduce using rule 106 (NUM -> FLOAT_NUM .)
    ASSIGN          reduce using rule 106 (NUM -> FLOAT_NUM .)
    PLUS_ASSIGN     reduce using rule 106 (NUM -> FLOAT_NUM .)
    MINUS_ASSIGN    reduce using rule 106 (NUM -> FLOAT_NUM .)
    MUL_ASSIGN      reduce using rule 106 (NUM -> FLOAT_NUM .)
    DIV_ASSIGN      reduce using rule 106 (NUM -> FLOAT_NUM .)
    AND_ASSIGN      reduce using rule 106 (NUM -> FLOAT_NUM .)
    OR_ASSIGN       reduce using rule 106 (NUM -> FLOAT_NUM .)
    XOR_ASSIGN      reduce using rule 106 (NUM -> FLOAT_NUM .)
    MOD_ASSIGN      reduce using rule 106 (NUM -> FLOAT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 106 (NUM -> FLOAT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 106 (NUM -> FLOAT_NUM .)
    R_PAREN         reduce using rule 106 (NUM -> FLOAT_NUM .)
    COMMA           reduce using rule 106 (NUM -> FLOAT_NUM .)


state 44

    (2) multiple_statements -> multiple_statements statement .

    IF              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    WHILE           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    SEMICOLON       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    HASH            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    TYPE            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    NOT             reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS_PLUS       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS_MINUS     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_PAREN         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    STRING          reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    ID              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    CHAR            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    INT_NUM         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    FLOAT_NUM       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    $end            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    R_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)


state 45

    (6) open -> IF condition . statement
    (7) open -> IF condition . closed ELSE open
    (11) closed -> IF condition . closed ELSE closed
    (4) statement -> . open
    (5) statement -> . closed
    (9) closed -> . simple
    (10) closed -> . block
    (11) closed -> . IF condition closed ELSE closed
    (12) closed -> . WHILE condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (20) simple -> . expr SEMICOLON
    (21) simple -> . header
    (22) simple -> . declaration
    (23) simple -> . function
    (24) simple -> . SEMICOLON
    (16) block -> . left_flower multiple_statements right_flower
    (17) block -> . left_flower right_flower
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (46) header -> . HASH INCLUDE STRING
    (47) header -> . HASH INCLUDE HEADER_FILE
    (14) declaration -> . TYPE ID SEMICOLON
    (15) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (43) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (18) left_flower -> . L_FLOWBRACE
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 94
    WHILE           shift and go to state 97
    SEMICOLON       shift and go to state 11
    HASH            shift and go to state 17
    TYPE            shift and go to state 19
    L_FLOWBRACE     shift and go to state 22
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    statement                      shift and go to state 95
    closed                         shift and go to state 96
    open                           shift and go to state 4
    simple                         shift and go to state 8
    block                          shift and go to state 9
    expr                           shift and go to state 10
    header                         shift and go to state 12
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    left_flower                    shift and go to state 15
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 46

    (13) condition -> L_PAREN . expr R_PAREN
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    expr                           shift and go to state 98
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 47

    (8) open -> WHILE condition . open
    (12) closed -> WHILE condition . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) closed -> . simple
    (10) closed -> . block
    (11) closed -> . IF condition closed ELSE closed
    (12) closed -> . WHILE condition closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . header
    (22) simple -> . declaration
    (23) simple -> . function
    (24) simple -> . SEMICOLON
    (16) block -> . left_flower multiple_statements right_flower
    (17) block -> . left_flower right_flower
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (46) header -> . HASH INCLUDE STRING
    (47) header -> . HASH INCLUDE HEADER_FILE
    (14) declaration -> . TYPE ID SEMICOLON
    (15) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (43) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (18) left_flower -> . L_FLOWBRACE
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    SEMICOLON       shift and go to state 11
    HASH            shift and go to state 17
    TYPE            shift and go to state 19
    L_FLOWBRACE     shift and go to state 22
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    open                           shift and go to state 99
    closed                         shift and go to state 100
    simple                         shift and go to state 8
    block                          shift and go to state 9
    expr                           shift and go to state 10
    header                         shift and go to state 12
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    left_flower                    shift and go to state 15
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 48

    (20) simple -> expr SEMICOLON .

    IF              reduce using rule 20 (simple -> expr SEMICOLON .)
    WHILE           reduce using rule 20 (simple -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 20 (simple -> expr SEMICOLON .)
    HASH            reduce using rule 20 (simple -> expr SEMICOLON .)
    TYPE            reduce using rule 20 (simple -> expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 20 (simple -> expr SEMICOLON .)
    NOT             reduce using rule 20 (simple -> expr SEMICOLON .)
    PLUS            reduce using rule 20 (simple -> expr SEMICOLON .)
    MINUS           reduce using rule 20 (simple -> expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 20 (simple -> expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 20 (simple -> expr SEMICOLON .)
    L_PAREN         reduce using rule 20 (simple -> expr SEMICOLON .)
    STRING          reduce using rule 20 (simple -> expr SEMICOLON .)
    ID              reduce using rule 20 (simple -> expr SEMICOLON .)
    CHAR            reduce using rule 20 (simple -> expr SEMICOLON .)
    INT_NUM         reduce using rule 20 (simple -> expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 20 (simple -> expr SEMICOLON .)
    $end            reduce using rule 20 (simple -> expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 20 (simple -> expr SEMICOLON .)
    ELSE            reduce using rule 20 (simple -> expr SEMICOLON .)


state 49

    (49) expr -> expr assignment . exprOR
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    exprOR                         shift and go to state 101
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 50

    (51) assignment -> ASSIGN .

    NOT             reduce using rule 51 (assignment -> ASSIGN .)
    PLUS            reduce using rule 51 (assignment -> ASSIGN .)
    MINUS           reduce using rule 51 (assignment -> ASSIGN .)
    PLUS_PLUS       reduce using rule 51 (assignment -> ASSIGN .)
    MINUS_MINUS     reduce using rule 51 (assignment -> ASSIGN .)
    L_PAREN         reduce using rule 51 (assignment -> ASSIGN .)
    STRING          reduce using rule 51 (assignment -> ASSIGN .)
    ID              reduce using rule 51 (assignment -> ASSIGN .)
    CHAR            reduce using rule 51 (assignment -> ASSIGN .)
    INT_NUM         reduce using rule 51 (assignment -> ASSIGN .)
    FLOAT_NUM       reduce using rule 51 (assignment -> ASSIGN .)


state 51

    (52) assignment -> PLUS_ASSIGN .

    NOT             reduce using rule 52 (assignment -> PLUS_ASSIGN .)
    PLUS            reduce using rule 52 (assignment -> PLUS_ASSIGN .)
    MINUS           reduce using rule 52 (assignment -> PLUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 52 (assignment -> PLUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 52 (assignment -> PLUS_ASSIGN .)
    L_PAREN         reduce using rule 52 (assignment -> PLUS_ASSIGN .)
    STRING          reduce using rule 52 (assignment -> PLUS_ASSIGN .)
    ID              reduce using rule 52 (assignment -> PLUS_ASSIGN .)
    CHAR            reduce using rule 52 (assignment -> PLUS_ASSIGN .)
    INT_NUM         reduce using rule 52 (assignment -> PLUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 52 (assignment -> PLUS_ASSIGN .)


state 52

    (53) assignment -> MINUS_ASSIGN .

    NOT             reduce using rule 53 (assignment -> MINUS_ASSIGN .)
    PLUS            reduce using rule 53 (assignment -> MINUS_ASSIGN .)
    MINUS           reduce using rule 53 (assignment -> MINUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 53 (assignment -> MINUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 53 (assignment -> MINUS_ASSIGN .)
    L_PAREN         reduce using rule 53 (assignment -> MINUS_ASSIGN .)
    STRING          reduce using rule 53 (assignment -> MINUS_ASSIGN .)
    ID              reduce using rule 53 (assignment -> MINUS_ASSIGN .)
    CHAR            reduce using rule 53 (assignment -> MINUS_ASSIGN .)
    INT_NUM         reduce using rule 53 (assignment -> MINUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 53 (assignment -> MINUS_ASSIGN .)


state 53

    (54) assignment -> MUL_ASSIGN .

    NOT             reduce using rule 54 (assignment -> MUL_ASSIGN .)
    PLUS            reduce using rule 54 (assignment -> MUL_ASSIGN .)
    MINUS           reduce using rule 54 (assignment -> MUL_ASSIGN .)
    PLUS_PLUS       reduce using rule 54 (assignment -> MUL_ASSIGN .)
    MINUS_MINUS     reduce using rule 54 (assignment -> MUL_ASSIGN .)
    L_PAREN         reduce using rule 54 (assignment -> MUL_ASSIGN .)
    STRING          reduce using rule 54 (assignment -> MUL_ASSIGN .)
    ID              reduce using rule 54 (assignment -> MUL_ASSIGN .)
    CHAR            reduce using rule 54 (assignment -> MUL_ASSIGN .)
    INT_NUM         reduce using rule 54 (assignment -> MUL_ASSIGN .)
    FLOAT_NUM       reduce using rule 54 (assignment -> MUL_ASSIGN .)


state 54

    (55) assignment -> DIV_ASSIGN .

    NOT             reduce using rule 55 (assignment -> DIV_ASSIGN .)
    PLUS            reduce using rule 55 (assignment -> DIV_ASSIGN .)
    MINUS           reduce using rule 55 (assignment -> DIV_ASSIGN .)
    PLUS_PLUS       reduce using rule 55 (assignment -> DIV_ASSIGN .)
    MINUS_MINUS     reduce using rule 55 (assignment -> DIV_ASSIGN .)
    L_PAREN         reduce using rule 55 (assignment -> DIV_ASSIGN .)
    STRING          reduce using rule 55 (assignment -> DIV_ASSIGN .)
    ID              reduce using rule 55 (assignment -> DIV_ASSIGN .)
    CHAR            reduce using rule 55 (assignment -> DIV_ASSIGN .)
    INT_NUM         reduce using rule 55 (assignment -> DIV_ASSIGN .)
    FLOAT_NUM       reduce using rule 55 (assignment -> DIV_ASSIGN .)


state 55

    (56) assignment -> AND_ASSIGN .

    NOT             reduce using rule 56 (assignment -> AND_ASSIGN .)
    PLUS            reduce using rule 56 (assignment -> AND_ASSIGN .)
    MINUS           reduce using rule 56 (assignment -> AND_ASSIGN .)
    PLUS_PLUS       reduce using rule 56 (assignment -> AND_ASSIGN .)
    MINUS_MINUS     reduce using rule 56 (assignment -> AND_ASSIGN .)
    L_PAREN         reduce using rule 56 (assignment -> AND_ASSIGN .)
    STRING          reduce using rule 56 (assignment -> AND_ASSIGN .)
    ID              reduce using rule 56 (assignment -> AND_ASSIGN .)
    CHAR            reduce using rule 56 (assignment -> AND_ASSIGN .)
    INT_NUM         reduce using rule 56 (assignment -> AND_ASSIGN .)
    FLOAT_NUM       reduce using rule 56 (assignment -> AND_ASSIGN .)


state 56

    (57) assignment -> OR_ASSIGN .

    NOT             reduce using rule 57 (assignment -> OR_ASSIGN .)
    PLUS            reduce using rule 57 (assignment -> OR_ASSIGN .)
    MINUS           reduce using rule 57 (assignment -> OR_ASSIGN .)
    PLUS_PLUS       reduce using rule 57 (assignment -> OR_ASSIGN .)
    MINUS_MINUS     reduce using rule 57 (assignment -> OR_ASSIGN .)
    L_PAREN         reduce using rule 57 (assignment -> OR_ASSIGN .)
    STRING          reduce using rule 57 (assignment -> OR_ASSIGN .)
    ID              reduce using rule 57 (assignment -> OR_ASSIGN .)
    CHAR            reduce using rule 57 (assignment -> OR_ASSIGN .)
    INT_NUM         reduce using rule 57 (assignment -> OR_ASSIGN .)
    FLOAT_NUM       reduce using rule 57 (assignment -> OR_ASSIGN .)


state 57

    (58) assignment -> XOR_ASSIGN .

    NOT             reduce using rule 58 (assignment -> XOR_ASSIGN .)
    PLUS            reduce using rule 58 (assignment -> XOR_ASSIGN .)
    MINUS           reduce using rule 58 (assignment -> XOR_ASSIGN .)
    PLUS_PLUS       reduce using rule 58 (assignment -> XOR_ASSIGN .)
    MINUS_MINUS     reduce using rule 58 (assignment -> XOR_ASSIGN .)
    L_PAREN         reduce using rule 58 (assignment -> XOR_ASSIGN .)
    STRING          reduce using rule 58 (assignment -> XOR_ASSIGN .)
    ID              reduce using rule 58 (assignment -> XOR_ASSIGN .)
    CHAR            reduce using rule 58 (assignment -> XOR_ASSIGN .)
    INT_NUM         reduce using rule 58 (assignment -> XOR_ASSIGN .)
    FLOAT_NUM       reduce using rule 58 (assignment -> XOR_ASSIGN .)


state 58

    (59) assignment -> MOD_ASSIGN .

    NOT             reduce using rule 59 (assignment -> MOD_ASSIGN .)
    PLUS            reduce using rule 59 (assignment -> MOD_ASSIGN .)
    MINUS           reduce using rule 59 (assignment -> MOD_ASSIGN .)
    PLUS_PLUS       reduce using rule 59 (assignment -> MOD_ASSIGN .)
    MINUS_MINUS     reduce using rule 59 (assignment -> MOD_ASSIGN .)
    L_PAREN         reduce using rule 59 (assignment -> MOD_ASSIGN .)
    STRING          reduce using rule 59 (assignment -> MOD_ASSIGN .)
    ID              reduce using rule 59 (assignment -> MOD_ASSIGN .)
    CHAR            reduce using rule 59 (assignment -> MOD_ASSIGN .)
    INT_NUM         reduce using rule 59 (assignment -> MOD_ASSIGN .)
    FLOAT_NUM       reduce using rule 59 (assignment -> MOD_ASSIGN .)


state 59

    (60) assignment -> L_SHIFT_ASSIGN .

    NOT             reduce using rule 60 (assignment -> L_SHIFT_ASSIGN .)
    PLUS            reduce using rule 60 (assignment -> L_SHIFT_ASSIGN .)
    MINUS           reduce using rule 60 (assignment -> L_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 60 (assignment -> L_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 60 (assignment -> L_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 60 (assignment -> L_SHIFT_ASSIGN .)
    STRING          reduce using rule 60 (assignment -> L_SHIFT_ASSIGN .)
    ID              reduce using rule 60 (assignment -> L_SHIFT_ASSIGN .)
    CHAR            reduce using rule 60 (assignment -> L_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 60 (assignment -> L_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 60 (assignment -> L_SHIFT_ASSIGN .)


state 60

    (61) assignment -> R_SHIFT_ASSIGN .

    NOT             reduce using rule 61 (assignment -> R_SHIFT_ASSIGN .)
    PLUS            reduce using rule 61 (assignment -> R_SHIFT_ASSIGN .)
    MINUS           reduce using rule 61 (assignment -> R_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 61 (assignment -> R_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 61 (assignment -> R_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 61 (assignment -> R_SHIFT_ASSIGN .)
    STRING          reduce using rule 61 (assignment -> R_SHIFT_ASSIGN .)
    ID              reduce using rule 61 (assignment -> R_SHIFT_ASSIGN .)
    CHAR            reduce using rule 61 (assignment -> R_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 61 (assignment -> R_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 61 (assignment -> R_SHIFT_ASSIGN .)


state 61

    (16) block -> left_flower multiple_statements . right_flower
    (2) multiple_statements -> multiple_statements . statement
    (19) right_flower -> . R_FLOWBRACE
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) closed -> . simple
    (10) closed -> . block
    (11) closed -> . IF condition closed ELSE closed
    (12) closed -> . WHILE condition closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . header
    (22) simple -> . declaration
    (23) simple -> . function
    (24) simple -> . SEMICOLON
    (16) block -> . left_flower multiple_statements right_flower
    (17) block -> . left_flower right_flower
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (46) header -> . HASH INCLUDE STRING
    (47) header -> . HASH INCLUDE HEADER_FILE
    (14) declaration -> . TYPE ID SEMICOLON
    (15) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (43) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (18) left_flower -> . L_FLOWBRACE
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    R_FLOWBRACE     shift and go to state 63
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    SEMICOLON       shift and go to state 11
    HASH            shift and go to state 17
    TYPE            shift and go to state 19
    L_FLOWBRACE     shift and go to state 22
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    left_flower                    shift and go to state 15
    right_flower                   shift and go to state 102
    statement                      shift and go to state 44
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 8
    block                          shift and go to state 9
    expr                           shift and go to state 10
    header                         shift and go to state 12
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 62

    (17) block -> left_flower right_flower .

    IF              reduce using rule 17 (block -> left_flower right_flower .)
    WHILE           reduce using rule 17 (block -> left_flower right_flower .)
    SEMICOLON       reduce using rule 17 (block -> left_flower right_flower .)
    HASH            reduce using rule 17 (block -> left_flower right_flower .)
    TYPE            reduce using rule 17 (block -> left_flower right_flower .)
    L_FLOWBRACE     reduce using rule 17 (block -> left_flower right_flower .)
    NOT             reduce using rule 17 (block -> left_flower right_flower .)
    PLUS            reduce using rule 17 (block -> left_flower right_flower .)
    MINUS           reduce using rule 17 (block -> left_flower right_flower .)
    PLUS_PLUS       reduce using rule 17 (block -> left_flower right_flower .)
    MINUS_MINUS     reduce using rule 17 (block -> left_flower right_flower .)
    L_PAREN         reduce using rule 17 (block -> left_flower right_flower .)
    STRING          reduce using rule 17 (block -> left_flower right_flower .)
    ID              reduce using rule 17 (block -> left_flower right_flower .)
    CHAR            reduce using rule 17 (block -> left_flower right_flower .)
    INT_NUM         reduce using rule 17 (block -> left_flower right_flower .)
    FLOAT_NUM       reduce using rule 17 (block -> left_flower right_flower .)
    $end            reduce using rule 17 (block -> left_flower right_flower .)
    R_FLOWBRACE     reduce using rule 17 (block -> left_flower right_flower .)
    ELSE            reduce using rule 17 (block -> left_flower right_flower .)


state 63

    (19) right_flower -> R_FLOWBRACE .

    IF              reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    WHILE           reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    SEMICOLON       reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    HASH            reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    TYPE            reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    L_FLOWBRACE     reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    NOT             reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    PLUS            reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    MINUS           reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    PLUS_PLUS       reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    MINUS_MINUS     reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    L_PAREN         reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    STRING          reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    ID              reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    CHAR            reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    INT_NUM         reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    FLOAT_NUM       reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    $end            reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    R_FLOWBRACE     reduce using rule 19 (right_flower -> R_FLOWBRACE .)
    ELSE            reduce using rule 19 (right_flower -> R_FLOWBRACE .)


state 64

    (62) exprOR -> exprOR OR . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    exprAND                        shift and go to state 103
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 65

    (46) header -> HASH INCLUDE . STRING
    (47) header -> HASH INCLUDE . HEADER_FILE

    STRING          shift and go to state 104
    HEADER_FILE     shift and go to state 105


state 66

    (14) declaration -> TYPE ID . SEMICOLON
    (15) declaration -> TYPE ID . ASSIGN expr SEMICOLON
    (43) function -> TYPE ID . L_PAREN dec_params R_PAREN function_2

    SEMICOLON       shift and go to state 106
    ASSIGN          shift and go to state 107
    L_PAREN         shift and go to state 108


state 67

    (25) function_call -> ID L_PAREN . call_params R_PAREN
    (26) call_params -> . empty
    (27) call_params -> . yes_call_params end_call_params
    (28) call_params -> . end_call_params
    (48) empty -> .
    (29) yes_call_params -> . yes_call_params expr COMMA
    (30) yes_call_params -> . expr COMMA
    (31) end_call_params -> . expr
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    R_PAREN         reduce using rule 48 (empty -> .)
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    call_params                    shift and go to state 109
    empty                          shift and go to state 110
    yes_call_params                shift and go to state 111
    end_call_params                shift and go to state 112
    expr                           shift and go to state 113
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 68

    (97) brace -> L_PAREN expr . R_PAREN
    (49) expr -> expr . assignment exprOR
    (51) assignment -> . ASSIGN
    (52) assignment -> . PLUS_ASSIGN
    (53) assignment -> . MINUS_ASSIGN
    (54) assignment -> . MUL_ASSIGN
    (55) assignment -> . DIV_ASSIGN
    (56) assignment -> . AND_ASSIGN
    (57) assignment -> . OR_ASSIGN
    (58) assignment -> . XOR_ASSIGN
    (59) assignment -> . MOD_ASSIGN
    (60) assignment -> . L_SHIFT_ASSIGN
    (61) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 114
    ASSIGN          shift and go to state 50
    PLUS_ASSIGN     shift and go to state 51
    MINUS_ASSIGN    shift and go to state 52
    MUL_ASSIGN      shift and go to state 53
    DIV_ASSIGN      shift and go to state 54
    AND_ASSIGN      shift and go to state 55
    OR_ASSIGN       shift and go to state 56
    XOR_ASSIGN      shift and go to state 57
    MOD_ASSIGN      shift and go to state 58
    L_SHIFT_ASSIGN  shift and go to state 59
    R_SHIFT_ASSIGN  shift and go to state 60

    assignment                     shift and go to state 49

state 69

    (64) exprAND -> exprAND AND . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    exprBITOR                      shift and go to state 115
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 70

    (66) exprBITOR -> exprBITOR BIT_OR . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    exprBITXOR                     shift and go to state 116
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 71

    (68) exprBITXOR -> exprBITXOR BIT_XOR . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    exprBITAND                     shift and go to state 117
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 72

    (70) exprBITAND -> exprBITAND BIT_AND . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    exprEQ                         shift and go to state 118
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 73

    (72) exprEQ -> exprEQ EQ . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    exprRELOP                      shift and go to state 119
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 74

    (73) exprEQ -> exprEQ NE . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    exprRELOP                      shift and go to state 120
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 75

    (75) exprRELOP -> exprRELOP relop . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    exprSHIFT                      shift and go to state 121
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 76

    (77) relop -> LE .

    NOT             reduce using rule 77 (relop -> LE .)
    PLUS            reduce using rule 77 (relop -> LE .)
    MINUS           reduce using rule 77 (relop -> LE .)
    PLUS_PLUS       reduce using rule 77 (relop -> LE .)
    MINUS_MINUS     reduce using rule 77 (relop -> LE .)
    L_PAREN         reduce using rule 77 (relop -> LE .)
    STRING          reduce using rule 77 (relop -> LE .)
    ID              reduce using rule 77 (relop -> LE .)
    CHAR            reduce using rule 77 (relop -> LE .)
    INT_NUM         reduce using rule 77 (relop -> LE .)
    FLOAT_NUM       reduce using rule 77 (relop -> LE .)


state 77

    (78) relop -> LT .

    NOT             reduce using rule 78 (relop -> LT .)
    PLUS            reduce using rule 78 (relop -> LT .)
    MINUS           reduce using rule 78 (relop -> LT .)
    PLUS_PLUS       reduce using rule 78 (relop -> LT .)
    MINUS_MINUS     reduce using rule 78 (relop -> LT .)
    L_PAREN         reduce using rule 78 (relop -> LT .)
    STRING          reduce using rule 78 (relop -> LT .)
    ID              reduce using rule 78 (relop -> LT .)
    CHAR            reduce using rule 78 (relop -> LT .)
    INT_NUM         reduce using rule 78 (relop -> LT .)
    FLOAT_NUM       reduce using rule 78 (relop -> LT .)


state 78

    (79) relop -> GE .

    NOT             reduce using rule 79 (relop -> GE .)
    PLUS            reduce using rule 79 (relop -> GE .)
    MINUS           reduce using rule 79 (relop -> GE .)
    PLUS_PLUS       reduce using rule 79 (relop -> GE .)
    MINUS_MINUS     reduce using rule 79 (relop -> GE .)
    L_PAREN         reduce using rule 79 (relop -> GE .)
    STRING          reduce using rule 79 (relop -> GE .)
    ID              reduce using rule 79 (relop -> GE .)
    CHAR            reduce using rule 79 (relop -> GE .)
    INT_NUM         reduce using rule 79 (relop -> GE .)
    FLOAT_NUM       reduce using rule 79 (relop -> GE .)


state 79

    (80) relop -> GT .

    NOT             reduce using rule 80 (relop -> GT .)
    PLUS            reduce using rule 80 (relop -> GT .)
    MINUS           reduce using rule 80 (relop -> GT .)
    PLUS_PLUS       reduce using rule 80 (relop -> GT .)
    MINUS_MINUS     reduce using rule 80 (relop -> GT .)
    L_PAREN         reduce using rule 80 (relop -> GT .)
    STRING          reduce using rule 80 (relop -> GT .)
    ID              reduce using rule 80 (relop -> GT .)
    CHAR            reduce using rule 80 (relop -> GT .)
    INT_NUM         reduce using rule 80 (relop -> GT .)
    FLOAT_NUM       reduce using rule 80 (relop -> GT .)


state 80

    (81) exprSHIFT -> exprSHIFT L_SHIFT . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    exprOP                         shift and go to state 122
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 81

    (82) exprSHIFT -> exprSHIFT R_SHIFT . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    exprOP                         shift and go to state 123
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 82

    (84) exprOP -> exprOP PLUS . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    term                           shift and go to state 124
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 83

    (85) exprOP -> exprOP MINUS . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    term                           shift and go to state 125
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 84

    (92) factor -> PLUS factor .

    MULTIPLY        reduce using rule 92 (factor -> PLUS factor .)
    DIVIDE          reduce using rule 92 (factor -> PLUS factor .)
    MOD             reduce using rule 92 (factor -> PLUS factor .)
    PLUS            reduce using rule 92 (factor -> PLUS factor .)
    MINUS           reduce using rule 92 (factor -> PLUS factor .)
    L_SHIFT         reduce using rule 92 (factor -> PLUS factor .)
    R_SHIFT         reduce using rule 92 (factor -> PLUS factor .)
    LE              reduce using rule 92 (factor -> PLUS factor .)
    LT              reduce using rule 92 (factor -> PLUS factor .)
    GE              reduce using rule 92 (factor -> PLUS factor .)
    GT              reduce using rule 92 (factor -> PLUS factor .)
    EQ              reduce using rule 92 (factor -> PLUS factor .)
    NE              reduce using rule 92 (factor -> PLUS factor .)
    BIT_AND         reduce using rule 92 (factor -> PLUS factor .)
    BIT_XOR         reduce using rule 92 (factor -> PLUS factor .)
    BIT_OR          reduce using rule 92 (factor -> PLUS factor .)
    AND             reduce using rule 92 (factor -> PLUS factor .)
    OR              reduce using rule 92 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 92 (factor -> PLUS factor .)
    ASSIGN          reduce using rule 92 (factor -> PLUS factor .)
    PLUS_ASSIGN     reduce using rule 92 (factor -> PLUS factor .)
    MINUS_ASSIGN    reduce using rule 92 (factor -> PLUS factor .)
    MUL_ASSIGN      reduce using rule 92 (factor -> PLUS factor .)
    DIV_ASSIGN      reduce using rule 92 (factor -> PLUS factor .)
    AND_ASSIGN      reduce using rule 92 (factor -> PLUS factor .)
    OR_ASSIGN       reduce using rule 92 (factor -> PLUS factor .)
    XOR_ASSIGN      reduce using rule 92 (factor -> PLUS factor .)
    MOD_ASSIGN      reduce using rule 92 (factor -> PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 92 (factor -> PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 92 (factor -> PLUS factor .)
    R_PAREN         reduce using rule 92 (factor -> PLUS factor .)
    COMMA           reduce using rule 92 (factor -> PLUS factor .)


state 85

    (87) term -> term MULTIPLY . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    factor                         shift and go to state 126
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 86

    (88) term -> term DIVIDE . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    factor                         shift and go to state 127
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 87

    (89) term -> term MOD . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    factor                         shift and go to state 128
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 88

    (93) factor -> MINUS factor .

    MULTIPLY        reduce using rule 93 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 93 (factor -> MINUS factor .)
    MOD             reduce using rule 93 (factor -> MINUS factor .)
    PLUS            reduce using rule 93 (factor -> MINUS factor .)
    MINUS           reduce using rule 93 (factor -> MINUS factor .)
    L_SHIFT         reduce using rule 93 (factor -> MINUS factor .)
    R_SHIFT         reduce using rule 93 (factor -> MINUS factor .)
    LE              reduce using rule 93 (factor -> MINUS factor .)
    LT              reduce using rule 93 (factor -> MINUS factor .)
    GE              reduce using rule 93 (factor -> MINUS factor .)
    GT              reduce using rule 93 (factor -> MINUS factor .)
    EQ              reduce using rule 93 (factor -> MINUS factor .)
    NE              reduce using rule 93 (factor -> MINUS factor .)
    BIT_AND         reduce using rule 93 (factor -> MINUS factor .)
    BIT_XOR         reduce using rule 93 (factor -> MINUS factor .)
    BIT_OR          reduce using rule 93 (factor -> MINUS factor .)
    AND             reduce using rule 93 (factor -> MINUS factor .)
    OR              reduce using rule 93 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 93 (factor -> MINUS factor .)
    ASSIGN          reduce using rule 93 (factor -> MINUS factor .)
    PLUS_ASSIGN     reduce using rule 93 (factor -> MINUS factor .)
    MINUS_ASSIGN    reduce using rule 93 (factor -> MINUS factor .)
    MUL_ASSIGN      reduce using rule 93 (factor -> MINUS factor .)
    DIV_ASSIGN      reduce using rule 93 (factor -> MINUS factor .)
    AND_ASSIGN      reduce using rule 93 (factor -> MINUS factor .)
    OR_ASSIGN       reduce using rule 93 (factor -> MINUS factor .)
    XOR_ASSIGN      reduce using rule 93 (factor -> MINUS factor .)
    MOD_ASSIGN      reduce using rule 93 (factor -> MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 93 (factor -> MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 93 (factor -> MINUS factor .)
    R_PAREN         reduce using rule 93 (factor -> MINUS factor .)
    COMMA           reduce using rule 93 (factor -> MINUS factor .)


state 89

    (91) factor -> NOT factor .

    MULTIPLY        reduce using rule 91 (factor -> NOT factor .)
    DIVIDE          reduce using rule 91 (factor -> NOT factor .)
    MOD             reduce using rule 91 (factor -> NOT factor .)
    PLUS            reduce using rule 91 (factor -> NOT factor .)
    MINUS           reduce using rule 91 (factor -> NOT factor .)
    L_SHIFT         reduce using rule 91 (factor -> NOT factor .)
    R_SHIFT         reduce using rule 91 (factor -> NOT factor .)
    LE              reduce using rule 91 (factor -> NOT factor .)
    LT              reduce using rule 91 (factor -> NOT factor .)
    GE              reduce using rule 91 (factor -> NOT factor .)
    GT              reduce using rule 91 (factor -> NOT factor .)
    EQ              reduce using rule 91 (factor -> NOT factor .)
    NE              reduce using rule 91 (factor -> NOT factor .)
    BIT_AND         reduce using rule 91 (factor -> NOT factor .)
    BIT_XOR         reduce using rule 91 (factor -> NOT factor .)
    BIT_OR          reduce using rule 91 (factor -> NOT factor .)
    AND             reduce using rule 91 (factor -> NOT factor .)
    OR              reduce using rule 91 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 91 (factor -> NOT factor .)
    ASSIGN          reduce using rule 91 (factor -> NOT factor .)
    PLUS_ASSIGN     reduce using rule 91 (factor -> NOT factor .)
    MINUS_ASSIGN    reduce using rule 91 (factor -> NOT factor .)
    MUL_ASSIGN      reduce using rule 91 (factor -> NOT factor .)
    DIV_ASSIGN      reduce using rule 91 (factor -> NOT factor .)
    AND_ASSIGN      reduce using rule 91 (factor -> NOT factor .)
    OR_ASSIGN       reduce using rule 91 (factor -> NOT factor .)
    XOR_ASSIGN      reduce using rule 91 (factor -> NOT factor .)
    MOD_ASSIGN      reduce using rule 91 (factor -> NOT factor .)
    L_SHIFT_ASSIGN  reduce using rule 91 (factor -> NOT factor .)
    R_SHIFT_ASSIGN  reduce using rule 91 (factor -> NOT factor .)
    R_PAREN         reduce using rule 91 (factor -> NOT factor .)
    COMMA           reduce using rule 91 (factor -> NOT factor .)


state 90

    (94) factor -> PLUS_PLUS factor .

    MULTIPLY        reduce using rule 94 (factor -> PLUS_PLUS factor .)
    DIVIDE          reduce using rule 94 (factor -> PLUS_PLUS factor .)
    MOD             reduce using rule 94 (factor -> PLUS_PLUS factor .)
    PLUS            reduce using rule 94 (factor -> PLUS_PLUS factor .)
    MINUS           reduce using rule 94 (factor -> PLUS_PLUS factor .)
    L_SHIFT         reduce using rule 94 (factor -> PLUS_PLUS factor .)
    R_SHIFT         reduce using rule 94 (factor -> PLUS_PLUS factor .)
    LE              reduce using rule 94 (factor -> PLUS_PLUS factor .)
    LT              reduce using rule 94 (factor -> PLUS_PLUS factor .)
    GE              reduce using rule 94 (factor -> PLUS_PLUS factor .)
    GT              reduce using rule 94 (factor -> PLUS_PLUS factor .)
    EQ              reduce using rule 94 (factor -> PLUS_PLUS factor .)
    NE              reduce using rule 94 (factor -> PLUS_PLUS factor .)
    BIT_AND         reduce using rule 94 (factor -> PLUS_PLUS factor .)
    BIT_XOR         reduce using rule 94 (factor -> PLUS_PLUS factor .)
    BIT_OR          reduce using rule 94 (factor -> PLUS_PLUS factor .)
    AND             reduce using rule 94 (factor -> PLUS_PLUS factor .)
    OR              reduce using rule 94 (factor -> PLUS_PLUS factor .)
    SEMICOLON       reduce using rule 94 (factor -> PLUS_PLUS factor .)
    ASSIGN          reduce using rule 94 (factor -> PLUS_PLUS factor .)
    PLUS_ASSIGN     reduce using rule 94 (factor -> PLUS_PLUS factor .)
    MINUS_ASSIGN    reduce using rule 94 (factor -> PLUS_PLUS factor .)
    MUL_ASSIGN      reduce using rule 94 (factor -> PLUS_PLUS factor .)
    DIV_ASSIGN      reduce using rule 94 (factor -> PLUS_PLUS factor .)
    AND_ASSIGN      reduce using rule 94 (factor -> PLUS_PLUS factor .)
    OR_ASSIGN       reduce using rule 94 (factor -> PLUS_PLUS factor .)
    XOR_ASSIGN      reduce using rule 94 (factor -> PLUS_PLUS factor .)
    MOD_ASSIGN      reduce using rule 94 (factor -> PLUS_PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 94 (factor -> PLUS_PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 94 (factor -> PLUS_PLUS factor .)
    R_PAREN         reduce using rule 94 (factor -> PLUS_PLUS factor .)
    COMMA           reduce using rule 94 (factor -> PLUS_PLUS factor .)


state 91

    (95) factor -> MINUS_MINUS factor .

    MULTIPLY        reduce using rule 95 (factor -> MINUS_MINUS factor .)
    DIVIDE          reduce using rule 95 (factor -> MINUS_MINUS factor .)
    MOD             reduce using rule 95 (factor -> MINUS_MINUS factor .)
    PLUS            reduce using rule 95 (factor -> MINUS_MINUS factor .)
    MINUS           reduce using rule 95 (factor -> MINUS_MINUS factor .)
    L_SHIFT         reduce using rule 95 (factor -> MINUS_MINUS factor .)
    R_SHIFT         reduce using rule 95 (factor -> MINUS_MINUS factor .)
    LE              reduce using rule 95 (factor -> MINUS_MINUS factor .)
    LT              reduce using rule 95 (factor -> MINUS_MINUS factor .)
    GE              reduce using rule 95 (factor -> MINUS_MINUS factor .)
    GT              reduce using rule 95 (factor -> MINUS_MINUS factor .)
    EQ              reduce using rule 95 (factor -> MINUS_MINUS factor .)
    NE              reduce using rule 95 (factor -> MINUS_MINUS factor .)
    BIT_AND         reduce using rule 95 (factor -> MINUS_MINUS factor .)
    BIT_XOR         reduce using rule 95 (factor -> MINUS_MINUS factor .)
    BIT_OR          reduce using rule 95 (factor -> MINUS_MINUS factor .)
    AND             reduce using rule 95 (factor -> MINUS_MINUS factor .)
    OR              reduce using rule 95 (factor -> MINUS_MINUS factor .)
    SEMICOLON       reduce using rule 95 (factor -> MINUS_MINUS factor .)
    ASSIGN          reduce using rule 95 (factor -> MINUS_MINUS factor .)
    PLUS_ASSIGN     reduce using rule 95 (factor -> MINUS_MINUS factor .)
    MINUS_ASSIGN    reduce using rule 95 (factor -> MINUS_MINUS factor .)
    MUL_ASSIGN      reduce using rule 95 (factor -> MINUS_MINUS factor .)
    DIV_ASSIGN      reduce using rule 95 (factor -> MINUS_MINUS factor .)
    AND_ASSIGN      reduce using rule 95 (factor -> MINUS_MINUS factor .)
    OR_ASSIGN       reduce using rule 95 (factor -> MINUS_MINUS factor .)
    XOR_ASSIGN      reduce using rule 95 (factor -> MINUS_MINUS factor .)
    MOD_ASSIGN      reduce using rule 95 (factor -> MINUS_MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 95 (factor -> MINUS_MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 95 (factor -> MINUS_MINUS factor .)
    R_PAREN         reduce using rule 95 (factor -> MINUS_MINUS factor .)
    COMMA           reduce using rule 95 (factor -> MINUS_MINUS factor .)


state 92

    (98) brace -> brace PLUS_PLUS .

    PLUS_PLUS       reduce using rule 98 (brace -> brace PLUS_PLUS .)
    MINUS_MINUS     reduce using rule 98 (brace -> brace PLUS_PLUS .)
    MULTIPLY        reduce using rule 98 (brace -> brace PLUS_PLUS .)
    DIVIDE          reduce using rule 98 (brace -> brace PLUS_PLUS .)
    MOD             reduce using rule 98 (brace -> brace PLUS_PLUS .)
    PLUS            reduce using rule 98 (brace -> brace PLUS_PLUS .)
    MINUS           reduce using rule 98 (brace -> brace PLUS_PLUS .)
    L_SHIFT         reduce using rule 98 (brace -> brace PLUS_PLUS .)
    R_SHIFT         reduce using rule 98 (brace -> brace PLUS_PLUS .)
    LE              reduce using rule 98 (brace -> brace PLUS_PLUS .)
    LT              reduce using rule 98 (brace -> brace PLUS_PLUS .)
    GE              reduce using rule 98 (brace -> brace PLUS_PLUS .)
    GT              reduce using rule 98 (brace -> brace PLUS_PLUS .)
    EQ              reduce using rule 98 (brace -> brace PLUS_PLUS .)
    NE              reduce using rule 98 (brace -> brace PLUS_PLUS .)
    BIT_AND         reduce using rule 98 (brace -> brace PLUS_PLUS .)
    BIT_XOR         reduce using rule 98 (brace -> brace PLUS_PLUS .)
    BIT_OR          reduce using rule 98 (brace -> brace PLUS_PLUS .)
    AND             reduce using rule 98 (brace -> brace PLUS_PLUS .)
    OR              reduce using rule 98 (brace -> brace PLUS_PLUS .)
    SEMICOLON       reduce using rule 98 (brace -> brace PLUS_PLUS .)
    ASSIGN          reduce using rule 98 (brace -> brace PLUS_PLUS .)
    PLUS_ASSIGN     reduce using rule 98 (brace -> brace PLUS_PLUS .)
    MINUS_ASSIGN    reduce using rule 98 (brace -> brace PLUS_PLUS .)
    MUL_ASSIGN      reduce using rule 98 (brace -> brace PLUS_PLUS .)
    DIV_ASSIGN      reduce using rule 98 (brace -> brace PLUS_PLUS .)
    AND_ASSIGN      reduce using rule 98 (brace -> brace PLUS_PLUS .)
    OR_ASSIGN       reduce using rule 98 (brace -> brace PLUS_PLUS .)
    XOR_ASSIGN      reduce using rule 98 (brace -> brace PLUS_PLUS .)
    MOD_ASSIGN      reduce using rule 98 (brace -> brace PLUS_PLUS .)
    L_SHIFT_ASSIGN  reduce using rule 98 (brace -> brace PLUS_PLUS .)
    R_SHIFT_ASSIGN  reduce using rule 98 (brace -> brace PLUS_PLUS .)
    R_PAREN         reduce using rule 98 (brace -> brace PLUS_PLUS .)
    COMMA           reduce using rule 98 (brace -> brace PLUS_PLUS .)


state 93

    (99) brace -> brace MINUS_MINUS .

    PLUS_PLUS       reduce using rule 99 (brace -> brace MINUS_MINUS .)
    MINUS_MINUS     reduce using rule 99 (brace -> brace MINUS_MINUS .)
    MULTIPLY        reduce using rule 99 (brace -> brace MINUS_MINUS .)
    DIVIDE          reduce using rule 99 (brace -> brace MINUS_MINUS .)
    MOD             reduce using rule 99 (brace -> brace MINUS_MINUS .)
    PLUS            reduce using rule 99 (brace -> brace MINUS_MINUS .)
    MINUS           reduce using rule 99 (brace -> brace MINUS_MINUS .)
    L_SHIFT         reduce using rule 99 (brace -> brace MINUS_MINUS .)
    R_SHIFT         reduce using rule 99 (brace -> brace MINUS_MINUS .)
    LE              reduce using rule 99 (brace -> brace MINUS_MINUS .)
    LT              reduce using rule 99 (brace -> brace MINUS_MINUS .)
    GE              reduce using rule 99 (brace -> brace MINUS_MINUS .)
    GT              reduce using rule 99 (brace -> brace MINUS_MINUS .)
    EQ              reduce using rule 99 (brace -> brace MINUS_MINUS .)
    NE              reduce using rule 99 (brace -> brace MINUS_MINUS .)
    BIT_AND         reduce using rule 99 (brace -> brace MINUS_MINUS .)
    BIT_XOR         reduce using rule 99 (brace -> brace MINUS_MINUS .)
    BIT_OR          reduce using rule 99 (brace -> brace MINUS_MINUS .)
    AND             reduce using rule 99 (brace -> brace MINUS_MINUS .)
    OR              reduce using rule 99 (brace -> brace MINUS_MINUS .)
    SEMICOLON       reduce using rule 99 (brace -> brace MINUS_MINUS .)
    ASSIGN          reduce using rule 99 (brace -> brace MINUS_MINUS .)
    PLUS_ASSIGN     reduce using rule 99 (brace -> brace MINUS_MINUS .)
    MINUS_ASSIGN    reduce using rule 99 (brace -> brace MINUS_MINUS .)
    MUL_ASSIGN      reduce using rule 99 (brace -> brace MINUS_MINUS .)
    DIV_ASSIGN      reduce using rule 99 (brace -> brace MINUS_MINUS .)
    AND_ASSIGN      reduce using rule 99 (brace -> brace MINUS_MINUS .)
    OR_ASSIGN       reduce using rule 99 (brace -> brace MINUS_MINUS .)
    XOR_ASSIGN      reduce using rule 99 (brace -> brace MINUS_MINUS .)
    MOD_ASSIGN      reduce using rule 99 (brace -> brace MINUS_MINUS .)
    L_SHIFT_ASSIGN  reduce using rule 99 (brace -> brace MINUS_MINUS .)
    R_SHIFT_ASSIGN  reduce using rule 99 (brace -> brace MINUS_MINUS .)
    R_PAREN         reduce using rule 99 (brace -> brace MINUS_MINUS .)
    COMMA           reduce using rule 99 (brace -> brace MINUS_MINUS .)


state 94

    (11) closed -> IF . condition closed ELSE closed
    (6) open -> IF . condition statement
    (7) open -> IF . condition closed ELSE open
    (13) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 46

    condition                      shift and go to state 129

state 95

    (6) open -> IF condition statement .

    IF              reduce using rule 6 (open -> IF condition statement .)
    WHILE           reduce using rule 6 (open -> IF condition statement .)
    SEMICOLON       reduce using rule 6 (open -> IF condition statement .)
    HASH            reduce using rule 6 (open -> IF condition statement .)
    TYPE            reduce using rule 6 (open -> IF condition statement .)
    L_FLOWBRACE     reduce using rule 6 (open -> IF condition statement .)
    NOT             reduce using rule 6 (open -> IF condition statement .)
    PLUS            reduce using rule 6 (open -> IF condition statement .)
    MINUS           reduce using rule 6 (open -> IF condition statement .)
    PLUS_PLUS       reduce using rule 6 (open -> IF condition statement .)
    MINUS_MINUS     reduce using rule 6 (open -> IF condition statement .)
    L_PAREN         reduce using rule 6 (open -> IF condition statement .)
    STRING          reduce using rule 6 (open -> IF condition statement .)
    ID              reduce using rule 6 (open -> IF condition statement .)
    CHAR            reduce using rule 6 (open -> IF condition statement .)
    INT_NUM         reduce using rule 6 (open -> IF condition statement .)
    FLOAT_NUM       reduce using rule 6 (open -> IF condition statement .)
    $end            reduce using rule 6 (open -> IF condition statement .)
    R_FLOWBRACE     reduce using rule 6 (open -> IF condition statement .)


state 96

    (7) open -> IF condition closed . ELSE open
    (11) closed -> IF condition closed . ELSE closed
    (5) statement -> closed .

    ELSE            shift and go to state 130
    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    HASH            reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    STRING          reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    CHAR            reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 97

    (12) closed -> WHILE . condition closed
    (8) open -> WHILE . condition open
    (13) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 46

    condition                      shift and go to state 131

state 98

    (13) condition -> L_PAREN expr . R_PAREN
    (49) expr -> expr . assignment exprOR
    (51) assignment -> . ASSIGN
    (52) assignment -> . PLUS_ASSIGN
    (53) assignment -> . MINUS_ASSIGN
    (54) assignment -> . MUL_ASSIGN
    (55) assignment -> . DIV_ASSIGN
    (56) assignment -> . AND_ASSIGN
    (57) assignment -> . OR_ASSIGN
    (58) assignment -> . XOR_ASSIGN
    (59) assignment -> . MOD_ASSIGN
    (60) assignment -> . L_SHIFT_ASSIGN
    (61) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 132
    ASSIGN          shift and go to state 50
    PLUS_ASSIGN     shift and go to state 51
    MINUS_ASSIGN    shift and go to state 52
    MUL_ASSIGN      shift and go to state 53
    DIV_ASSIGN      shift and go to state 54
    AND_ASSIGN      shift and go to state 55
    OR_ASSIGN       shift and go to state 56
    XOR_ASSIGN      shift and go to state 57
    MOD_ASSIGN      shift and go to state 58
    L_SHIFT_ASSIGN  shift and go to state 59
    R_SHIFT_ASSIGN  shift and go to state 60

    assignment                     shift and go to state 49

state 99

    (8) open -> WHILE condition open .

    IF              reduce using rule 8 (open -> WHILE condition open .)
    WHILE           reduce using rule 8 (open -> WHILE condition open .)
    SEMICOLON       reduce using rule 8 (open -> WHILE condition open .)
    HASH            reduce using rule 8 (open -> WHILE condition open .)
    TYPE            reduce using rule 8 (open -> WHILE condition open .)
    L_FLOWBRACE     reduce using rule 8 (open -> WHILE condition open .)
    NOT             reduce using rule 8 (open -> WHILE condition open .)
    PLUS            reduce using rule 8 (open -> WHILE condition open .)
    MINUS           reduce using rule 8 (open -> WHILE condition open .)
    PLUS_PLUS       reduce using rule 8 (open -> WHILE condition open .)
    MINUS_MINUS     reduce using rule 8 (open -> WHILE condition open .)
    L_PAREN         reduce using rule 8 (open -> WHILE condition open .)
    STRING          reduce using rule 8 (open -> WHILE condition open .)
    ID              reduce using rule 8 (open -> WHILE condition open .)
    CHAR            reduce using rule 8 (open -> WHILE condition open .)
    INT_NUM         reduce using rule 8 (open -> WHILE condition open .)
    FLOAT_NUM       reduce using rule 8 (open -> WHILE condition open .)
    $end            reduce using rule 8 (open -> WHILE condition open .)
    R_FLOWBRACE     reduce using rule 8 (open -> WHILE condition open .)


state 100

    (12) closed -> WHILE condition closed .

    IF              reduce using rule 12 (closed -> WHILE condition closed .)
    WHILE           reduce using rule 12 (closed -> WHILE condition closed .)
    SEMICOLON       reduce using rule 12 (closed -> WHILE condition closed .)
    HASH            reduce using rule 12 (closed -> WHILE condition closed .)
    TYPE            reduce using rule 12 (closed -> WHILE condition closed .)
    L_FLOWBRACE     reduce using rule 12 (closed -> WHILE condition closed .)
    NOT             reduce using rule 12 (closed -> WHILE condition closed .)
    PLUS            reduce using rule 12 (closed -> WHILE condition closed .)
    MINUS           reduce using rule 12 (closed -> WHILE condition closed .)
    PLUS_PLUS       reduce using rule 12 (closed -> WHILE condition closed .)
    MINUS_MINUS     reduce using rule 12 (closed -> WHILE condition closed .)
    L_PAREN         reduce using rule 12 (closed -> WHILE condition closed .)
    STRING          reduce using rule 12 (closed -> WHILE condition closed .)
    ID              reduce using rule 12 (closed -> WHILE condition closed .)
    CHAR            reduce using rule 12 (closed -> WHILE condition closed .)
    INT_NUM         reduce using rule 12 (closed -> WHILE condition closed .)
    FLOAT_NUM       reduce using rule 12 (closed -> WHILE condition closed .)
    $end            reduce using rule 12 (closed -> WHILE condition closed .)
    R_FLOWBRACE     reduce using rule 12 (closed -> WHILE condition closed .)
    ELSE            reduce using rule 12 (closed -> WHILE condition closed .)


state 101

    (49) expr -> expr assignment exprOR .
    (62) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 49 (expr -> expr assignment exprOR .)
    ASSIGN          reduce using rule 49 (expr -> expr assignment exprOR .)
    PLUS_ASSIGN     reduce using rule 49 (expr -> expr assignment exprOR .)
    MINUS_ASSIGN    reduce using rule 49 (expr -> expr assignment exprOR .)
    MUL_ASSIGN      reduce using rule 49 (expr -> expr assignment exprOR .)
    DIV_ASSIGN      reduce using rule 49 (expr -> expr assignment exprOR .)
    AND_ASSIGN      reduce using rule 49 (expr -> expr assignment exprOR .)
    OR_ASSIGN       reduce using rule 49 (expr -> expr assignment exprOR .)
    XOR_ASSIGN      reduce using rule 49 (expr -> expr assignment exprOR .)
    MOD_ASSIGN      reduce using rule 49 (expr -> expr assignment exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 49 (expr -> expr assignment exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 49 (expr -> expr assignment exprOR .)
    R_PAREN         reduce using rule 49 (expr -> expr assignment exprOR .)
    COMMA           reduce using rule 49 (expr -> expr assignment exprOR .)
    OR              shift and go to state 64


state 102

    (16) block -> left_flower multiple_statements right_flower .

    IF              reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    WHILE           reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    SEMICOLON       reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    HASH            reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    TYPE            reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    L_FLOWBRACE     reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    NOT             reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    PLUS            reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    MINUS           reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    PLUS_PLUS       reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    MINUS_MINUS     reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    L_PAREN         reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    STRING          reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    ID              reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    CHAR            reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    INT_NUM         reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    FLOAT_NUM       reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    $end            reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    R_FLOWBRACE     reduce using rule 16 (block -> left_flower multiple_statements right_flower .)
    ELSE            reduce using rule 16 (block -> left_flower multiple_statements right_flower .)


state 103

    (62) exprOR -> exprOR OR exprAND .
    (64) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    SEMICOLON       reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    ASSIGN          reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    PLUS_ASSIGN     reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    MINUS_ASSIGN    reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    MUL_ASSIGN      reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    DIV_ASSIGN      reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    AND_ASSIGN      reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    OR_ASSIGN       reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    XOR_ASSIGN      reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    MOD_ASSIGN      reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    R_PAREN         reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    COMMA           reduce using rule 62 (exprOR -> exprOR OR exprAND .)
    AND             shift and go to state 69


state 104

    (46) header -> HASH INCLUDE STRING .

    IF              reduce using rule 46 (header -> HASH INCLUDE STRING .)
    WHILE           reduce using rule 46 (header -> HASH INCLUDE STRING .)
    SEMICOLON       reduce using rule 46 (header -> HASH INCLUDE STRING .)
    HASH            reduce using rule 46 (header -> HASH INCLUDE STRING .)
    TYPE            reduce using rule 46 (header -> HASH INCLUDE STRING .)
    L_FLOWBRACE     reduce using rule 46 (header -> HASH INCLUDE STRING .)
    NOT             reduce using rule 46 (header -> HASH INCLUDE STRING .)
    PLUS            reduce using rule 46 (header -> HASH INCLUDE STRING .)
    MINUS           reduce using rule 46 (header -> HASH INCLUDE STRING .)
    PLUS_PLUS       reduce using rule 46 (header -> HASH INCLUDE STRING .)
    MINUS_MINUS     reduce using rule 46 (header -> HASH INCLUDE STRING .)
    L_PAREN         reduce using rule 46 (header -> HASH INCLUDE STRING .)
    STRING          reduce using rule 46 (header -> HASH INCLUDE STRING .)
    ID              reduce using rule 46 (header -> HASH INCLUDE STRING .)
    CHAR            reduce using rule 46 (header -> HASH INCLUDE STRING .)
    INT_NUM         reduce using rule 46 (header -> HASH INCLUDE STRING .)
    FLOAT_NUM       reduce using rule 46 (header -> HASH INCLUDE STRING .)
    $end            reduce using rule 46 (header -> HASH INCLUDE STRING .)
    R_FLOWBRACE     reduce using rule 46 (header -> HASH INCLUDE STRING .)
    ELSE            reduce using rule 46 (header -> HASH INCLUDE STRING .)


state 105

    (47) header -> HASH INCLUDE HEADER_FILE .

    IF              reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    WHILE           reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    SEMICOLON       reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    HASH            reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    TYPE            reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    L_FLOWBRACE     reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    NOT             reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    PLUS            reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    MINUS           reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    PLUS_PLUS       reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    MINUS_MINUS     reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    L_PAREN         reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    STRING          reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    ID              reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    CHAR            reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    INT_NUM         reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    FLOAT_NUM       reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    $end            reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    R_FLOWBRACE     reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)
    ELSE            reduce using rule 47 (header -> HASH INCLUDE HEADER_FILE .)


state 106

    (14) declaration -> TYPE ID SEMICOLON .

    IF              reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    WHILE           reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    SEMICOLON       reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    HASH            reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    TYPE            reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    NOT             reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    PLUS            reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    MINUS           reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    L_PAREN         reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    STRING          reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    ID              reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    CHAR            reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    INT_NUM         reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    $end            reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)
    ELSE            reduce using rule 14 (declaration -> TYPE ID SEMICOLON .)


state 107

    (15) declaration -> TYPE ID ASSIGN . expr SEMICOLON
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    expr                           shift and go to state 133
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 108

    (43) function -> TYPE ID L_PAREN . dec_params R_PAREN function_2
    (40) dec_params -> . empty
    (41) dec_params -> . yes_dec_params end_dec_params
    (42) dec_params -> . end_dec_params
    (48) empty -> .
    (32) yes_dec_params -> . yes_dec_params TYPE expr COMMA
    (33) yes_dec_params -> . yes_dec_params TYPE COMMA
    (34) yes_dec_params -> . yes_dec_params TYPE MULTIPLY COMMA
    (35) yes_dec_params -> . TYPE expr COMMA
    (36) yes_dec_params -> . TYPE COMMA
    (37) yes_dec_params -> . TYPE MULTIPLY COMMA
    (38) end_dec_params -> . TYPE expr
    (39) end_dec_params -> . TYPE

    R_PAREN         reduce using rule 48 (empty -> .)
    TYPE            shift and go to state 134

    dec_params                     shift and go to state 135
    empty                          shift and go to state 136
    yes_dec_params                 shift and go to state 137
    end_dec_params                 shift and go to state 138

state 109

    (25) function_call -> ID L_PAREN call_params . R_PAREN

    R_PAREN         shift and go to state 139


state 110

    (26) call_params -> empty .

    R_PAREN         reduce using rule 26 (call_params -> empty .)


state 111

    (27) call_params -> yes_call_params . end_call_params
    (29) yes_call_params -> yes_call_params . expr COMMA
    (31) end_call_params -> . expr
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    end_call_params                shift and go to state 140
    expr                           shift and go to state 141
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 112

    (28) call_params -> end_call_params .

    R_PAREN         reduce using rule 28 (call_params -> end_call_params .)


state 113

    (30) yes_call_params -> expr . COMMA
    (31) end_call_params -> expr .
    (49) expr -> expr . assignment exprOR
    (51) assignment -> . ASSIGN
    (52) assignment -> . PLUS_ASSIGN
    (53) assignment -> . MINUS_ASSIGN
    (54) assignment -> . MUL_ASSIGN
    (55) assignment -> . DIV_ASSIGN
    (56) assignment -> . AND_ASSIGN
    (57) assignment -> . OR_ASSIGN
    (58) assignment -> . XOR_ASSIGN
    (59) assignment -> . MOD_ASSIGN
    (60) assignment -> . L_SHIFT_ASSIGN
    (61) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 142
    R_PAREN         reduce using rule 31 (end_call_params -> expr .)
    ASSIGN          shift and go to state 50
    PLUS_ASSIGN     shift and go to state 51
    MINUS_ASSIGN    shift and go to state 52
    MUL_ASSIGN      shift and go to state 53
    DIV_ASSIGN      shift and go to state 54
    AND_ASSIGN      shift and go to state 55
    OR_ASSIGN       shift and go to state 56
    XOR_ASSIGN      shift and go to state 57
    MOD_ASSIGN      shift and go to state 58
    L_SHIFT_ASSIGN  shift and go to state 59
    R_SHIFT_ASSIGN  shift and go to state 60

    assignment                     shift and go to state 49

state 114

    (97) brace -> L_PAREN expr R_PAREN .

    PLUS_PLUS       reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    MULTIPLY        reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    DIVIDE          reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    MOD             reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT         reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT         reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    LE              reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    LT              reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    GE              reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    GT              reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    EQ              reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    NE              reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    BIT_AND         reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    BIT_XOR         reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    BIT_OR          reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    AND             reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    OR              reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    ASSIGN          reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    PLUS_ASSIGN     reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    MINUS_ASSIGN    reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    MUL_ASSIGN      reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    DIV_ASSIGN      reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    AND_ASSIGN      reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    OR_ASSIGN       reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    XOR_ASSIGN      reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    MOD_ASSIGN      reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT_ASSIGN  reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT_ASSIGN  reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    R_PAREN         reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)
    COMMA           reduce using rule 97 (brace -> L_PAREN expr R_PAREN .)


state 115

    (64) exprAND -> exprAND AND exprBITOR .
    (66) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    OR              reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    SEMICOLON       reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    ASSIGN          reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    PLUS_ASSIGN     reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    MINUS_ASSIGN    reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    MUL_ASSIGN      reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    DIV_ASSIGN      reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    AND_ASSIGN      reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    OR_ASSIGN       reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    XOR_ASSIGN      reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    MOD_ASSIGN      reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    R_PAREN         reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    COMMA           reduce using rule 64 (exprAND -> exprAND AND exprBITOR .)
    BIT_OR          shift and go to state 70


state 116

    (66) exprBITOR -> exprBITOR BIT_OR exprBITXOR .
    (68) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND             reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR              reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    SEMICOLON       reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    ASSIGN          reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MUL_ASSIGN      reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    DIV_ASSIGN      reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND_ASSIGN      reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR_ASSIGN       reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    XOR_ASSIGN      reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MOD_ASSIGN      reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_PAREN         reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    COMMA           reduce using rule 66 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    BIT_XOR         shift and go to state 71


state 117

    (68) exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .
    (70) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_OR          reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND             reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR              reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    SEMICOLON       reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    ASSIGN          reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    PLUS_ASSIGN     reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MINUS_ASSIGN    reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MUL_ASSIGN      reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    DIV_ASSIGN      reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND_ASSIGN      reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR_ASSIGN       reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    XOR_ASSIGN      reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MOD_ASSIGN      reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_PAREN         reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    COMMA           reduce using rule 68 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_AND         shift and go to state 72


state 118

    (70) exprBITAND -> exprBITAND BIT_AND exprEQ .
    (72) exprEQ -> exprEQ . EQ exprRELOP
    (73) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_XOR         reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_OR          reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND             reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR              reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    SEMICOLON       reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    ASSIGN          reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    PLUS_ASSIGN     reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MINUS_ASSIGN    reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MUL_ASSIGN      reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    DIV_ASSIGN      reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND_ASSIGN      reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR_ASSIGN       reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    XOR_ASSIGN      reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MOD_ASSIGN      reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_PAREN         reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    COMMA           reduce using rule 70 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    EQ              shift and go to state 73
    NE              shift and go to state 74


state 119

    (72) exprEQ -> exprEQ EQ exprRELOP .
    (75) exprRELOP -> exprRELOP . relop exprSHIFT
    (77) relop -> . LE
    (78) relop -> . LT
    (79) relop -> . GE
    (80) relop -> . GT

    EQ              reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    NE              reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_AND         reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_XOR         reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_OR          reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    AND             reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    OR              reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    SEMICOLON       reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    ASSIGN          reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    PLUS_ASSIGN     reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    MINUS_ASSIGN    reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    MUL_ASSIGN      reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    DIV_ASSIGN      reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    AND_ASSIGN      reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    OR_ASSIGN       reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    XOR_ASSIGN      reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    MOD_ASSIGN      reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    R_PAREN         reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    COMMA           reduce using rule 72 (exprEQ -> exprEQ EQ exprRELOP .)
    LE              shift and go to state 76
    LT              shift and go to state 77
    GE              shift and go to state 78
    GT              shift and go to state 79

    relop                          shift and go to state 75

state 120

    (73) exprEQ -> exprEQ NE exprRELOP .
    (75) exprRELOP -> exprRELOP . relop exprSHIFT
    (77) relop -> . LE
    (78) relop -> . LT
    (79) relop -> . GE
    (80) relop -> . GT

    EQ              reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    NE              reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_AND         reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_XOR         reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_OR          reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    AND             reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    OR              reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    SEMICOLON       reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    ASSIGN          reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    PLUS_ASSIGN     reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    MINUS_ASSIGN    reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    MUL_ASSIGN      reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    DIV_ASSIGN      reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    AND_ASSIGN      reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    OR_ASSIGN       reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    XOR_ASSIGN      reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    MOD_ASSIGN      reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    R_PAREN         reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    COMMA           reduce using rule 73 (exprEQ -> exprEQ NE exprRELOP .)
    LE              shift and go to state 76
    LT              shift and go to state 77
    GE              shift and go to state 78
    GT              shift and go to state 79

    relop                          shift and go to state 75

state 121

    (75) exprRELOP -> exprRELOP relop exprSHIFT .
    (81) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (82) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    LT              reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GE              reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GT              reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    EQ              reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    NE              reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_AND         reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_XOR         reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_OR          reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND             reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR              reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    SEMICOLON       reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    ASSIGN          reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MUL_ASSIGN      reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    DIV_ASSIGN      reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND_ASSIGN      reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR_ASSIGN       reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    XOR_ASSIGN      reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MOD_ASSIGN      reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_PAREN         reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    COMMA           reduce using rule 75 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT         shift and go to state 80
    R_SHIFT         shift and go to state 81


state 122

    (81) exprSHIFT -> exprSHIFT L_SHIFT exprOP .
    (84) exprOP -> exprOP . PLUS term
    (85) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT         reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LE              reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LT              reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GE              reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GT              reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    EQ              reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    NE              reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_AND         reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_XOR         reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_OR          reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND             reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR              reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    SEMICOLON       reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    ASSIGN          reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_PAREN         reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    COMMA           reduce using rule 81 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 123

    (82) exprSHIFT -> exprSHIFT R_SHIFT exprOP .
    (84) exprOP -> exprOP . PLUS term
    (85) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT         reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LE              reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LT              reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GE              reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GT              reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    EQ              reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    NE              reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_AND         reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_XOR         reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_OR          reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND             reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR              reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    SEMICOLON       reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    ASSIGN          reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_PAREN         reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    COMMA           reduce using rule 82 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 124

    (84) exprOP -> exprOP PLUS term .
    (87) term -> term . MULTIPLY factor
    (88) term -> term . DIVIDE factor
    (89) term -> term . MOD factor

    PLUS            reduce using rule 84 (exprOP -> exprOP PLUS term .)
    MINUS           reduce using rule 84 (exprOP -> exprOP PLUS term .)
    L_SHIFT         reduce using rule 84 (exprOP -> exprOP PLUS term .)
    R_SHIFT         reduce using rule 84 (exprOP -> exprOP PLUS term .)
    LE              reduce using rule 84 (exprOP -> exprOP PLUS term .)
    LT              reduce using rule 84 (exprOP -> exprOP PLUS term .)
    GE              reduce using rule 84 (exprOP -> exprOP PLUS term .)
    GT              reduce using rule 84 (exprOP -> exprOP PLUS term .)
    EQ              reduce using rule 84 (exprOP -> exprOP PLUS term .)
    NE              reduce using rule 84 (exprOP -> exprOP PLUS term .)
    BIT_AND         reduce using rule 84 (exprOP -> exprOP PLUS term .)
    BIT_XOR         reduce using rule 84 (exprOP -> exprOP PLUS term .)
    BIT_OR          reduce using rule 84 (exprOP -> exprOP PLUS term .)
    AND             reduce using rule 84 (exprOP -> exprOP PLUS term .)
    OR              reduce using rule 84 (exprOP -> exprOP PLUS term .)
    SEMICOLON       reduce using rule 84 (exprOP -> exprOP PLUS term .)
    ASSIGN          reduce using rule 84 (exprOP -> exprOP PLUS term .)
    PLUS_ASSIGN     reduce using rule 84 (exprOP -> exprOP PLUS term .)
    MINUS_ASSIGN    reduce using rule 84 (exprOP -> exprOP PLUS term .)
    MUL_ASSIGN      reduce using rule 84 (exprOP -> exprOP PLUS term .)
    DIV_ASSIGN      reduce using rule 84 (exprOP -> exprOP PLUS term .)
    AND_ASSIGN      reduce using rule 84 (exprOP -> exprOP PLUS term .)
    OR_ASSIGN       reduce using rule 84 (exprOP -> exprOP PLUS term .)
    XOR_ASSIGN      reduce using rule 84 (exprOP -> exprOP PLUS term .)
    MOD_ASSIGN      reduce using rule 84 (exprOP -> exprOP PLUS term .)
    L_SHIFT_ASSIGN  reduce using rule 84 (exprOP -> exprOP PLUS term .)
    R_SHIFT_ASSIGN  reduce using rule 84 (exprOP -> exprOP PLUS term .)
    R_PAREN         reduce using rule 84 (exprOP -> exprOP PLUS term .)
    COMMA           reduce using rule 84 (exprOP -> exprOP PLUS term .)
    MULTIPLY        shift and go to state 85
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 87


state 125

    (85) exprOP -> exprOP MINUS term .
    (87) term -> term . MULTIPLY factor
    (88) term -> term . DIVIDE factor
    (89) term -> term . MOD factor

    PLUS            reduce using rule 85 (exprOP -> exprOP MINUS term .)
    MINUS           reduce using rule 85 (exprOP -> exprOP MINUS term .)
    L_SHIFT         reduce using rule 85 (exprOP -> exprOP MINUS term .)
    R_SHIFT         reduce using rule 85 (exprOP -> exprOP MINUS term .)
    LE              reduce using rule 85 (exprOP -> exprOP MINUS term .)
    LT              reduce using rule 85 (exprOP -> exprOP MINUS term .)
    GE              reduce using rule 85 (exprOP -> exprOP MINUS term .)
    GT              reduce using rule 85 (exprOP -> exprOP MINUS term .)
    EQ              reduce using rule 85 (exprOP -> exprOP MINUS term .)
    NE              reduce using rule 85 (exprOP -> exprOP MINUS term .)
    BIT_AND         reduce using rule 85 (exprOP -> exprOP MINUS term .)
    BIT_XOR         reduce using rule 85 (exprOP -> exprOP MINUS term .)
    BIT_OR          reduce using rule 85 (exprOP -> exprOP MINUS term .)
    AND             reduce using rule 85 (exprOP -> exprOP MINUS term .)
    OR              reduce using rule 85 (exprOP -> exprOP MINUS term .)
    SEMICOLON       reduce using rule 85 (exprOP -> exprOP MINUS term .)
    ASSIGN          reduce using rule 85 (exprOP -> exprOP MINUS term .)
    PLUS_ASSIGN     reduce using rule 85 (exprOP -> exprOP MINUS term .)
    MINUS_ASSIGN    reduce using rule 85 (exprOP -> exprOP MINUS term .)
    MUL_ASSIGN      reduce using rule 85 (exprOP -> exprOP MINUS term .)
    DIV_ASSIGN      reduce using rule 85 (exprOP -> exprOP MINUS term .)
    AND_ASSIGN      reduce using rule 85 (exprOP -> exprOP MINUS term .)
    OR_ASSIGN       reduce using rule 85 (exprOP -> exprOP MINUS term .)
    XOR_ASSIGN      reduce using rule 85 (exprOP -> exprOP MINUS term .)
    MOD_ASSIGN      reduce using rule 85 (exprOP -> exprOP MINUS term .)
    L_SHIFT_ASSIGN  reduce using rule 85 (exprOP -> exprOP MINUS term .)
    R_SHIFT_ASSIGN  reduce using rule 85 (exprOP -> exprOP MINUS term .)
    R_PAREN         reduce using rule 85 (exprOP -> exprOP MINUS term .)
    COMMA           reduce using rule 85 (exprOP -> exprOP MINUS term .)
    MULTIPLY        shift and go to state 85
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 87


state 126

    (87) term -> term MULTIPLY factor .

    MULTIPLY        reduce using rule 87 (term -> term MULTIPLY factor .)
    DIVIDE          reduce using rule 87 (term -> term MULTIPLY factor .)
    MOD             reduce using rule 87 (term -> term MULTIPLY factor .)
    PLUS            reduce using rule 87 (term -> term MULTIPLY factor .)
    MINUS           reduce using rule 87 (term -> term MULTIPLY factor .)
    L_SHIFT         reduce using rule 87 (term -> term MULTIPLY factor .)
    R_SHIFT         reduce using rule 87 (term -> term MULTIPLY factor .)
    LE              reduce using rule 87 (term -> term MULTIPLY factor .)
    LT              reduce using rule 87 (term -> term MULTIPLY factor .)
    GE              reduce using rule 87 (term -> term MULTIPLY factor .)
    GT              reduce using rule 87 (term -> term MULTIPLY factor .)
    EQ              reduce using rule 87 (term -> term MULTIPLY factor .)
    NE              reduce using rule 87 (term -> term MULTIPLY factor .)
    BIT_AND         reduce using rule 87 (term -> term MULTIPLY factor .)
    BIT_XOR         reduce using rule 87 (term -> term MULTIPLY factor .)
    BIT_OR          reduce using rule 87 (term -> term MULTIPLY factor .)
    AND             reduce using rule 87 (term -> term MULTIPLY factor .)
    OR              reduce using rule 87 (term -> term MULTIPLY factor .)
    SEMICOLON       reduce using rule 87 (term -> term MULTIPLY factor .)
    ASSIGN          reduce using rule 87 (term -> term MULTIPLY factor .)
    PLUS_ASSIGN     reduce using rule 87 (term -> term MULTIPLY factor .)
    MINUS_ASSIGN    reduce using rule 87 (term -> term MULTIPLY factor .)
    MUL_ASSIGN      reduce using rule 87 (term -> term MULTIPLY factor .)
    DIV_ASSIGN      reduce using rule 87 (term -> term MULTIPLY factor .)
    AND_ASSIGN      reduce using rule 87 (term -> term MULTIPLY factor .)
    OR_ASSIGN       reduce using rule 87 (term -> term MULTIPLY factor .)
    XOR_ASSIGN      reduce using rule 87 (term -> term MULTIPLY factor .)
    MOD_ASSIGN      reduce using rule 87 (term -> term MULTIPLY factor .)
    L_SHIFT_ASSIGN  reduce using rule 87 (term -> term MULTIPLY factor .)
    R_SHIFT_ASSIGN  reduce using rule 87 (term -> term MULTIPLY factor .)
    R_PAREN         reduce using rule 87 (term -> term MULTIPLY factor .)
    COMMA           reduce using rule 87 (term -> term MULTIPLY factor .)


state 127

    (88) term -> term DIVIDE factor .

    MULTIPLY        reduce using rule 88 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 88 (term -> term DIVIDE factor .)
    MOD             reduce using rule 88 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 88 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 88 (term -> term DIVIDE factor .)
    L_SHIFT         reduce using rule 88 (term -> term DIVIDE factor .)
    R_SHIFT         reduce using rule 88 (term -> term DIVIDE factor .)
    LE              reduce using rule 88 (term -> term DIVIDE factor .)
    LT              reduce using rule 88 (term -> term DIVIDE factor .)
    GE              reduce using rule 88 (term -> term DIVIDE factor .)
    GT              reduce using rule 88 (term -> term DIVIDE factor .)
    EQ              reduce using rule 88 (term -> term DIVIDE factor .)
    NE              reduce using rule 88 (term -> term DIVIDE factor .)
    BIT_AND         reduce using rule 88 (term -> term DIVIDE factor .)
    BIT_XOR         reduce using rule 88 (term -> term DIVIDE factor .)
    BIT_OR          reduce using rule 88 (term -> term DIVIDE factor .)
    AND             reduce using rule 88 (term -> term DIVIDE factor .)
    OR              reduce using rule 88 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 88 (term -> term DIVIDE factor .)
    ASSIGN          reduce using rule 88 (term -> term DIVIDE factor .)
    PLUS_ASSIGN     reduce using rule 88 (term -> term DIVIDE factor .)
    MINUS_ASSIGN    reduce using rule 88 (term -> term DIVIDE factor .)
    MUL_ASSIGN      reduce using rule 88 (term -> term DIVIDE factor .)
    DIV_ASSIGN      reduce using rule 88 (term -> term DIVIDE factor .)
    AND_ASSIGN      reduce using rule 88 (term -> term DIVIDE factor .)
    OR_ASSIGN       reduce using rule 88 (term -> term DIVIDE factor .)
    XOR_ASSIGN      reduce using rule 88 (term -> term DIVIDE factor .)
    MOD_ASSIGN      reduce using rule 88 (term -> term DIVIDE factor .)
    L_SHIFT_ASSIGN  reduce using rule 88 (term -> term DIVIDE factor .)
    R_SHIFT_ASSIGN  reduce using rule 88 (term -> term DIVIDE factor .)
    R_PAREN         reduce using rule 88 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 88 (term -> term DIVIDE factor .)


state 128

    (89) term -> term MOD factor .

    MULTIPLY        reduce using rule 89 (term -> term MOD factor .)
    DIVIDE          reduce using rule 89 (term -> term MOD factor .)
    MOD             reduce using rule 89 (term -> term MOD factor .)
    PLUS            reduce using rule 89 (term -> term MOD factor .)
    MINUS           reduce using rule 89 (term -> term MOD factor .)
    L_SHIFT         reduce using rule 89 (term -> term MOD factor .)
    R_SHIFT         reduce using rule 89 (term -> term MOD factor .)
    LE              reduce using rule 89 (term -> term MOD factor .)
    LT              reduce using rule 89 (term -> term MOD factor .)
    GE              reduce using rule 89 (term -> term MOD factor .)
    GT              reduce using rule 89 (term -> term MOD factor .)
    EQ              reduce using rule 89 (term -> term MOD factor .)
    NE              reduce using rule 89 (term -> term MOD factor .)
    BIT_AND         reduce using rule 89 (term -> term MOD factor .)
    BIT_XOR         reduce using rule 89 (term -> term MOD factor .)
    BIT_OR          reduce using rule 89 (term -> term MOD factor .)
    AND             reduce using rule 89 (term -> term MOD factor .)
    OR              reduce using rule 89 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 89 (term -> term MOD factor .)
    ASSIGN          reduce using rule 89 (term -> term MOD factor .)
    PLUS_ASSIGN     reduce using rule 89 (term -> term MOD factor .)
    MINUS_ASSIGN    reduce using rule 89 (term -> term MOD factor .)
    MUL_ASSIGN      reduce using rule 89 (term -> term MOD factor .)
    DIV_ASSIGN      reduce using rule 89 (term -> term MOD factor .)
    AND_ASSIGN      reduce using rule 89 (term -> term MOD factor .)
    OR_ASSIGN       reduce using rule 89 (term -> term MOD factor .)
    XOR_ASSIGN      reduce using rule 89 (term -> term MOD factor .)
    MOD_ASSIGN      reduce using rule 89 (term -> term MOD factor .)
    L_SHIFT_ASSIGN  reduce using rule 89 (term -> term MOD factor .)
    R_SHIFT_ASSIGN  reduce using rule 89 (term -> term MOD factor .)
    R_PAREN         reduce using rule 89 (term -> term MOD factor .)
    COMMA           reduce using rule 89 (term -> term MOD factor .)


state 129

    (11) closed -> IF condition . closed ELSE closed
    (6) open -> IF condition . statement
    (7) open -> IF condition . closed ELSE open
    (9) closed -> . simple
    (10) closed -> . block
    (11) closed -> . IF condition closed ELSE closed
    (12) closed -> . WHILE condition closed
    (4) statement -> . open
    (5) statement -> . closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . header
    (22) simple -> . declaration
    (23) simple -> . function
    (24) simple -> . SEMICOLON
    (16) block -> . left_flower multiple_statements right_flower
    (17) block -> . left_flower right_flower
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (46) header -> . HASH INCLUDE STRING
    (47) header -> . HASH INCLUDE HEADER_FILE
    (14) declaration -> . TYPE ID SEMICOLON
    (15) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (43) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (18) left_flower -> . L_FLOWBRACE
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 94
    WHILE           shift and go to state 97
    SEMICOLON       shift and go to state 11
    HASH            shift and go to state 17
    TYPE            shift and go to state 19
    L_FLOWBRACE     shift and go to state 22
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    closed                         shift and go to state 143
    statement                      shift and go to state 95
    open                           shift and go to state 4
    simple                         shift and go to state 8
    block                          shift and go to state 9
    expr                           shift and go to state 10
    header                         shift and go to state 12
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    left_flower                    shift and go to state 15
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 130

    (7) open -> IF condition closed ELSE . open
    (11) closed -> IF condition closed ELSE . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) closed -> . simple
    (10) closed -> . block
    (11) closed -> . IF condition closed ELSE closed
    (12) closed -> . WHILE condition closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . header
    (22) simple -> . declaration
    (23) simple -> . function
    (24) simple -> . SEMICOLON
    (16) block -> . left_flower multiple_statements right_flower
    (17) block -> . left_flower right_flower
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (46) header -> . HASH INCLUDE STRING
    (47) header -> . HASH INCLUDE HEADER_FILE
    (14) declaration -> . TYPE ID SEMICOLON
    (15) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (43) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (18) left_flower -> . L_FLOWBRACE
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    SEMICOLON       shift and go to state 11
    HASH            shift and go to state 17
    TYPE            shift and go to state 19
    L_FLOWBRACE     shift and go to state 22
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    closed                         shift and go to state 144
    open                           shift and go to state 145
    simple                         shift and go to state 8
    block                          shift and go to state 9
    expr                           shift and go to state 10
    header                         shift and go to state 12
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    left_flower                    shift and go to state 15
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 131

    (12) closed -> WHILE condition . closed
    (8) open -> WHILE condition . open
    (9) closed -> . simple
    (10) closed -> . block
    (11) closed -> . IF condition closed ELSE closed
    (12) closed -> . WHILE condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (20) simple -> . expr SEMICOLON
    (21) simple -> . header
    (22) simple -> . declaration
    (23) simple -> . function
    (24) simple -> . SEMICOLON
    (16) block -> . left_flower multiple_statements right_flower
    (17) block -> . left_flower right_flower
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (46) header -> . HASH INCLUDE STRING
    (47) header -> . HASH INCLUDE HEADER_FILE
    (14) declaration -> . TYPE ID SEMICOLON
    (15) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (43) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (18) left_flower -> . L_FLOWBRACE
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 94
    WHILE           shift and go to state 97
    SEMICOLON       shift and go to state 11
    HASH            shift and go to state 17
    TYPE            shift and go to state 19
    L_FLOWBRACE     shift and go to state 22
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    closed                         shift and go to state 100
    open                           shift and go to state 99
    simple                         shift and go to state 8
    block                          shift and go to state 9
    expr                           shift and go to state 10
    header                         shift and go to state 12
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    left_flower                    shift and go to state 15
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 132

    (13) condition -> L_PAREN expr R_PAREN .

    IF              reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    WHILE           reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    HASH            reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    TYPE            reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    NOT             reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    PLUS_PLUS       reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    L_PAREN         reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    STRING          reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    ID              reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    CHAR            reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    INT_NUM         reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)
    FLOAT_NUM       reduce using rule 13 (condition -> L_PAREN expr R_PAREN .)


state 133

    (15) declaration -> TYPE ID ASSIGN expr . SEMICOLON
    (49) expr -> expr . assignment exprOR
    (51) assignment -> . ASSIGN
    (52) assignment -> . PLUS_ASSIGN
    (53) assignment -> . MINUS_ASSIGN
    (54) assignment -> . MUL_ASSIGN
    (55) assignment -> . DIV_ASSIGN
    (56) assignment -> . AND_ASSIGN
    (57) assignment -> . OR_ASSIGN
    (58) assignment -> . XOR_ASSIGN
    (59) assignment -> . MOD_ASSIGN
    (60) assignment -> . L_SHIFT_ASSIGN
    (61) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 146
    ASSIGN          shift and go to state 50
    PLUS_ASSIGN     shift and go to state 51
    MINUS_ASSIGN    shift and go to state 52
    MUL_ASSIGN      shift and go to state 53
    DIV_ASSIGN      shift and go to state 54
    AND_ASSIGN      shift and go to state 55
    OR_ASSIGN       shift and go to state 56
    XOR_ASSIGN      shift and go to state 57
    MOD_ASSIGN      shift and go to state 58
    L_SHIFT_ASSIGN  shift and go to state 59
    R_SHIFT_ASSIGN  shift and go to state 60

    assignment                     shift and go to state 49

state 134

    (35) yes_dec_params -> TYPE . expr COMMA
    (36) yes_dec_params -> TYPE . COMMA
    (37) yes_dec_params -> TYPE . MULTIPLY COMMA
    (38) end_dec_params -> TYPE . expr
    (39) end_dec_params -> TYPE .
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    COMMA           shift and go to state 148
    MULTIPLY        shift and go to state 149
    R_PAREN         reduce using rule 39 (end_dec_params -> TYPE .)
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    expr                           shift and go to state 147
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 135

    (43) function -> TYPE ID L_PAREN dec_params . R_PAREN function_2

    R_PAREN         shift and go to state 150


state 136

    (40) dec_params -> empty .

    R_PAREN         reduce using rule 40 (dec_params -> empty .)


state 137

    (41) dec_params -> yes_dec_params . end_dec_params
    (32) yes_dec_params -> yes_dec_params . TYPE expr COMMA
    (33) yes_dec_params -> yes_dec_params . TYPE COMMA
    (34) yes_dec_params -> yes_dec_params . TYPE MULTIPLY COMMA
    (38) end_dec_params -> . TYPE expr
    (39) end_dec_params -> . TYPE

    TYPE            shift and go to state 152

    end_dec_params                 shift and go to state 151

state 138

    (42) dec_params -> end_dec_params .

    R_PAREN         reduce using rule 42 (dec_params -> end_dec_params .)


state 139

    (25) function_call -> ID L_PAREN call_params R_PAREN .

    PLUS_PLUS       reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    MINUS_MINUS     reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    MULTIPLY        reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    DIVIDE          reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    MOD             reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    PLUS            reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    MINUS           reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    L_SHIFT         reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_SHIFT         reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    LE              reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    LT              reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    GE              reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    GT              reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    EQ              reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    NE              reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    BIT_AND         reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    BIT_XOR         reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    BIT_OR          reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    AND             reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    OR              reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    SEMICOLON       reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    ASSIGN          reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    PLUS_ASSIGN     reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    MINUS_ASSIGN    reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    MUL_ASSIGN      reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    DIV_ASSIGN      reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    AND_ASSIGN      reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    OR_ASSIGN       reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    XOR_ASSIGN      reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    MOD_ASSIGN      reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    L_SHIFT_ASSIGN  reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_SHIFT_ASSIGN  reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_PAREN         reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)
    COMMA           reduce using rule 25 (function_call -> ID L_PAREN call_params R_PAREN .)


state 140

    (27) call_params -> yes_call_params end_call_params .

    R_PAREN         reduce using rule 27 (call_params -> yes_call_params end_call_params .)


state 141

    (29) yes_call_params -> yes_call_params expr . COMMA
    (31) end_call_params -> expr .
    (49) expr -> expr . assignment exprOR
    (51) assignment -> . ASSIGN
    (52) assignment -> . PLUS_ASSIGN
    (53) assignment -> . MINUS_ASSIGN
    (54) assignment -> . MUL_ASSIGN
    (55) assignment -> . DIV_ASSIGN
    (56) assignment -> . AND_ASSIGN
    (57) assignment -> . OR_ASSIGN
    (58) assignment -> . XOR_ASSIGN
    (59) assignment -> . MOD_ASSIGN
    (60) assignment -> . L_SHIFT_ASSIGN
    (61) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 153
    R_PAREN         reduce using rule 31 (end_call_params -> expr .)
    ASSIGN          shift and go to state 50
    PLUS_ASSIGN     shift and go to state 51
    MINUS_ASSIGN    shift and go to state 52
    MUL_ASSIGN      shift and go to state 53
    DIV_ASSIGN      shift and go to state 54
    AND_ASSIGN      shift and go to state 55
    OR_ASSIGN       shift and go to state 56
    XOR_ASSIGN      shift and go to state 57
    MOD_ASSIGN      shift and go to state 58
    L_SHIFT_ASSIGN  shift and go to state 59
    R_SHIFT_ASSIGN  shift and go to state 60

    assignment                     shift and go to state 49

state 142

    (30) yes_call_params -> expr COMMA .

    NOT             reduce using rule 30 (yes_call_params -> expr COMMA .)
    PLUS            reduce using rule 30 (yes_call_params -> expr COMMA .)
    MINUS           reduce using rule 30 (yes_call_params -> expr COMMA .)
    PLUS_PLUS       reduce using rule 30 (yes_call_params -> expr COMMA .)
    MINUS_MINUS     reduce using rule 30 (yes_call_params -> expr COMMA .)
    L_PAREN         reduce using rule 30 (yes_call_params -> expr COMMA .)
    STRING          reduce using rule 30 (yes_call_params -> expr COMMA .)
    ID              reduce using rule 30 (yes_call_params -> expr COMMA .)
    CHAR            reduce using rule 30 (yes_call_params -> expr COMMA .)
    INT_NUM         reduce using rule 30 (yes_call_params -> expr COMMA .)
    FLOAT_NUM       reduce using rule 30 (yes_call_params -> expr COMMA .)


state 143

    (11) closed -> IF condition closed . ELSE closed
    (7) open -> IF condition closed . ELSE open
    (5) statement -> closed .

    ELSE            shift and go to state 154
    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    HASH            reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    STRING          reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    CHAR            reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 144

    (11) closed -> IF condition closed ELSE closed .

    IF              reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    WHILE           reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    SEMICOLON       reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    HASH            reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    TYPE            reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    L_FLOWBRACE     reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    NOT             reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    PLUS            reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    MINUS           reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    PLUS_PLUS       reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    MINUS_MINUS     reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    L_PAREN         reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    STRING          reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    ID              reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    CHAR            reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    INT_NUM         reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    FLOAT_NUM       reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    $end            reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    R_FLOWBRACE     reduce using rule 11 (closed -> IF condition closed ELSE closed .)
    ELSE            reduce using rule 11 (closed -> IF condition closed ELSE closed .)


state 145

    (7) open -> IF condition closed ELSE open .

    IF              reduce using rule 7 (open -> IF condition closed ELSE open .)
    WHILE           reduce using rule 7 (open -> IF condition closed ELSE open .)
    SEMICOLON       reduce using rule 7 (open -> IF condition closed ELSE open .)
    HASH            reduce using rule 7 (open -> IF condition closed ELSE open .)
    TYPE            reduce using rule 7 (open -> IF condition closed ELSE open .)
    L_FLOWBRACE     reduce using rule 7 (open -> IF condition closed ELSE open .)
    NOT             reduce using rule 7 (open -> IF condition closed ELSE open .)
    PLUS            reduce using rule 7 (open -> IF condition closed ELSE open .)
    MINUS           reduce using rule 7 (open -> IF condition closed ELSE open .)
    PLUS_PLUS       reduce using rule 7 (open -> IF condition closed ELSE open .)
    MINUS_MINUS     reduce using rule 7 (open -> IF condition closed ELSE open .)
    L_PAREN         reduce using rule 7 (open -> IF condition closed ELSE open .)
    STRING          reduce using rule 7 (open -> IF condition closed ELSE open .)
    ID              reduce using rule 7 (open -> IF condition closed ELSE open .)
    CHAR            reduce using rule 7 (open -> IF condition closed ELSE open .)
    INT_NUM         reduce using rule 7 (open -> IF condition closed ELSE open .)
    FLOAT_NUM       reduce using rule 7 (open -> IF condition closed ELSE open .)
    $end            reduce using rule 7 (open -> IF condition closed ELSE open .)
    R_FLOWBRACE     reduce using rule 7 (open -> IF condition closed ELSE open .)


state 146

    (15) declaration -> TYPE ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    HASH            reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 15 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)


state 147

    (35) yes_dec_params -> TYPE expr . COMMA
    (38) end_dec_params -> TYPE expr .
    (49) expr -> expr . assignment exprOR
    (51) assignment -> . ASSIGN
    (52) assignment -> . PLUS_ASSIGN
    (53) assignment -> . MINUS_ASSIGN
    (54) assignment -> . MUL_ASSIGN
    (55) assignment -> . DIV_ASSIGN
    (56) assignment -> . AND_ASSIGN
    (57) assignment -> . OR_ASSIGN
    (58) assignment -> . XOR_ASSIGN
    (59) assignment -> . MOD_ASSIGN
    (60) assignment -> . L_SHIFT_ASSIGN
    (61) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 155
    R_PAREN         reduce using rule 38 (end_dec_params -> TYPE expr .)
    ASSIGN          shift and go to state 50
    PLUS_ASSIGN     shift and go to state 51
    MINUS_ASSIGN    shift and go to state 52
    MUL_ASSIGN      shift and go to state 53
    DIV_ASSIGN      shift and go to state 54
    AND_ASSIGN      shift and go to state 55
    OR_ASSIGN       shift and go to state 56
    XOR_ASSIGN      shift and go to state 57
    MOD_ASSIGN      shift and go to state 58
    L_SHIFT_ASSIGN  shift and go to state 59
    R_SHIFT_ASSIGN  shift and go to state 60

    assignment                     shift and go to state 49

state 148

    (36) yes_dec_params -> TYPE COMMA .

    TYPE            reduce using rule 36 (yes_dec_params -> TYPE COMMA .)


state 149

    (37) yes_dec_params -> TYPE MULTIPLY . COMMA

    COMMA           shift and go to state 156


state 150

    (43) function -> TYPE ID L_PAREN dec_params R_PAREN . function_2
    (44) function_2 -> . SEMICOLON
    (45) function_2 -> . block
    (16) block -> . left_flower multiple_statements right_flower
    (17) block -> . left_flower right_flower
    (18) left_flower -> . L_FLOWBRACE

    SEMICOLON       shift and go to state 158
    L_FLOWBRACE     shift and go to state 22

    function_2                     shift and go to state 157
    block                          shift and go to state 159
    left_flower                    shift and go to state 15

state 151

    (41) dec_params -> yes_dec_params end_dec_params .

    R_PAREN         reduce using rule 41 (dec_params -> yes_dec_params end_dec_params .)


state 152

    (32) yes_dec_params -> yes_dec_params TYPE . expr COMMA
    (33) yes_dec_params -> yes_dec_params TYPE . COMMA
    (34) yes_dec_params -> yes_dec_params TYPE . MULTIPLY COMMA
    (38) end_dec_params -> TYPE . expr
    (39) end_dec_params -> TYPE .
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    COMMA           shift and go to state 161
    MULTIPLY        shift and go to state 162
    R_PAREN         reduce using rule 39 (end_dec_params -> TYPE .)
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    expr                           shift and go to state 160
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 153

    (29) yes_call_params -> yes_call_params expr COMMA .

    NOT             reduce using rule 29 (yes_call_params -> yes_call_params expr COMMA .)
    PLUS            reduce using rule 29 (yes_call_params -> yes_call_params expr COMMA .)
    MINUS           reduce using rule 29 (yes_call_params -> yes_call_params expr COMMA .)
    PLUS_PLUS       reduce using rule 29 (yes_call_params -> yes_call_params expr COMMA .)
    MINUS_MINUS     reduce using rule 29 (yes_call_params -> yes_call_params expr COMMA .)
    L_PAREN         reduce using rule 29 (yes_call_params -> yes_call_params expr COMMA .)
    STRING          reduce using rule 29 (yes_call_params -> yes_call_params expr COMMA .)
    ID              reduce using rule 29 (yes_call_params -> yes_call_params expr COMMA .)
    CHAR            reduce using rule 29 (yes_call_params -> yes_call_params expr COMMA .)
    INT_NUM         reduce using rule 29 (yes_call_params -> yes_call_params expr COMMA .)
    FLOAT_NUM       reduce using rule 29 (yes_call_params -> yes_call_params expr COMMA .)


state 154

    (11) closed -> IF condition closed ELSE . closed
    (7) open -> IF condition closed ELSE . open
    (9) closed -> . simple
    (10) closed -> . block
    (11) closed -> . IF condition closed ELSE closed
    (12) closed -> . WHILE condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (20) simple -> . expr SEMICOLON
    (21) simple -> . header
    (22) simple -> . declaration
    (23) simple -> . function
    (24) simple -> . SEMICOLON
    (16) block -> . left_flower multiple_statements right_flower
    (17) block -> . left_flower right_flower
    (49) expr -> . expr assignment exprOR
    (50) expr -> . exprOR
    (46) header -> . HASH INCLUDE STRING
    (47) header -> . HASH INCLUDE HEADER_FILE
    (14) declaration -> . TYPE ID SEMICOLON
    (15) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (43) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (18) left_flower -> . L_FLOWBRACE
    (62) exprOR -> . exprOR OR exprAND
    (63) exprOR -> . exprAND
    (64) exprAND -> . exprAND AND exprBITOR
    (65) exprAND -> . exprBITOR
    (66) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (67) exprBITOR -> . exprBITXOR
    (68) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (69) exprBITXOR -> . exprBITAND
    (70) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (71) exprBITAND -> . exprEQ
    (72) exprEQ -> . exprEQ EQ exprRELOP
    (73) exprEQ -> . exprEQ NE exprRELOP
    (74) exprEQ -> . exprRELOP
    (75) exprRELOP -> . exprRELOP relop exprSHIFT
    (76) exprRELOP -> . exprSHIFT
    (81) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (82) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (83) exprSHIFT -> . exprOP
    (84) exprOP -> . exprOP PLUS term
    (85) exprOP -> . exprOP MINUS term
    (86) exprOP -> . term
    (87) term -> . term MULTIPLY factor
    (88) term -> . term DIVIDE factor
    (89) term -> . term MOD factor
    (90) term -> . factor
    (91) factor -> . NOT factor
    (92) factor -> . PLUS factor
    (93) factor -> . MINUS factor
    (94) factor -> . PLUS_PLUS factor
    (95) factor -> . MINUS_MINUS factor
    (96) factor -> . brace
    (97) brace -> . L_PAREN expr R_PAREN
    (98) brace -> . brace PLUS_PLUS
    (99) brace -> . brace MINUS_MINUS
    (100) brace -> . NUM
    (101) brace -> . STRING
    (102) brace -> . ID
    (103) brace -> . CHAR
    (104) brace -> . function_call
    (105) NUM -> . INT_NUM
    (106) NUM -> . FLOAT_NUM
    (25) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 94
    WHILE           shift and go to state 97
    SEMICOLON       shift and go to state 11
    HASH            shift and go to state 17
    TYPE            shift and go to state 19
    L_FLOWBRACE     shift and go to state 22
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    STRING          shift and go to state 18
    ID              shift and go to state 20
    CHAR            shift and go to state 40
    INT_NUM         shift and go to state 42
    FLOAT_NUM       shift and go to state 43

    closed                         shift and go to state 144
    open                           shift and go to state 145
    simple                         shift and go to state 8
    block                          shift and go to state 9
    expr                           shift and go to state 10
    header                         shift and go to state 12
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    left_flower                    shift and go to state 15
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38
    NUM                            shift and go to state 39
    function_call                  shift and go to state 41

state 155

    (35) yes_dec_params -> TYPE expr COMMA .

    TYPE            reduce using rule 35 (yes_dec_params -> TYPE expr COMMA .)


state 156

    (37) yes_dec_params -> TYPE MULTIPLY COMMA .

    TYPE            reduce using rule 37 (yes_dec_params -> TYPE MULTIPLY COMMA .)


state 157

    (43) function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .

    IF              reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    WHILE           reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    SEMICOLON       reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    HASH            reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    TYPE            reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    L_FLOWBRACE     reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    NOT             reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    PLUS            reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    MINUS           reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    PLUS_PLUS       reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    MINUS_MINUS     reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    L_PAREN         reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    STRING          reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    ID              reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    CHAR            reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    INT_NUM         reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    FLOAT_NUM       reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    $end            reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    R_FLOWBRACE     reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    ELSE            reduce using rule 43 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)


state 158

    (44) function_2 -> SEMICOLON .

    IF              reduce using rule 44 (function_2 -> SEMICOLON .)
    WHILE           reduce using rule 44 (function_2 -> SEMICOLON .)
    SEMICOLON       reduce using rule 44 (function_2 -> SEMICOLON .)
    HASH            reduce using rule 44 (function_2 -> SEMICOLON .)
    TYPE            reduce using rule 44 (function_2 -> SEMICOLON .)
    L_FLOWBRACE     reduce using rule 44 (function_2 -> SEMICOLON .)
    NOT             reduce using rule 44 (function_2 -> SEMICOLON .)
    PLUS            reduce using rule 44 (function_2 -> SEMICOLON .)
    MINUS           reduce using rule 44 (function_2 -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 44 (function_2 -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 44 (function_2 -> SEMICOLON .)
    L_PAREN         reduce using rule 44 (function_2 -> SEMICOLON .)
    STRING          reduce using rule 44 (function_2 -> SEMICOLON .)
    ID              reduce using rule 44 (function_2 -> SEMICOLON .)
    CHAR            reduce using rule 44 (function_2 -> SEMICOLON .)
    INT_NUM         reduce using rule 44 (function_2 -> SEMICOLON .)
    FLOAT_NUM       reduce using rule 44 (function_2 -> SEMICOLON .)
    $end            reduce using rule 44 (function_2 -> SEMICOLON .)
    R_FLOWBRACE     reduce using rule 44 (function_2 -> SEMICOLON .)
    ELSE            reduce using rule 44 (function_2 -> SEMICOLON .)


state 159

    (45) function_2 -> block .

    IF              reduce using rule 45 (function_2 -> block .)
    WHILE           reduce using rule 45 (function_2 -> block .)
    SEMICOLON       reduce using rule 45 (function_2 -> block .)
    HASH            reduce using rule 45 (function_2 -> block .)
    TYPE            reduce using rule 45 (function_2 -> block .)
    L_FLOWBRACE     reduce using rule 45 (function_2 -> block .)
    NOT             reduce using rule 45 (function_2 -> block .)
    PLUS            reduce using rule 45 (function_2 -> block .)
    MINUS           reduce using rule 45 (function_2 -> block .)
    PLUS_PLUS       reduce using rule 45 (function_2 -> block .)
    MINUS_MINUS     reduce using rule 45 (function_2 -> block .)
    L_PAREN         reduce using rule 45 (function_2 -> block .)
    STRING          reduce using rule 45 (function_2 -> block .)
    ID              reduce using rule 45 (function_2 -> block .)
    CHAR            reduce using rule 45 (function_2 -> block .)
    INT_NUM         reduce using rule 45 (function_2 -> block .)
    FLOAT_NUM       reduce using rule 45 (function_2 -> block .)
    $end            reduce using rule 45 (function_2 -> block .)
    R_FLOWBRACE     reduce using rule 45 (function_2 -> block .)
    ELSE            reduce using rule 45 (function_2 -> block .)


state 160

    (32) yes_dec_params -> yes_dec_params TYPE expr . COMMA
    (38) end_dec_params -> TYPE expr .
    (49) expr -> expr . assignment exprOR
    (51) assignment -> . ASSIGN
    (52) assignment -> . PLUS_ASSIGN
    (53) assignment -> . MINUS_ASSIGN
    (54) assignment -> . MUL_ASSIGN
    (55) assignment -> . DIV_ASSIGN
    (56) assignment -> . AND_ASSIGN
    (57) assignment -> . OR_ASSIGN
    (58) assignment -> . XOR_ASSIGN
    (59) assignment -> . MOD_ASSIGN
    (60) assignment -> . L_SHIFT_ASSIGN
    (61) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 163
    R_PAREN         reduce using rule 38 (end_dec_params -> TYPE expr .)
    ASSIGN          shift and go to state 50
    PLUS_ASSIGN     shift and go to state 51
    MINUS_ASSIGN    shift and go to state 52
    MUL_ASSIGN      shift and go to state 53
    DIV_ASSIGN      shift and go to state 54
    AND_ASSIGN      shift and go to state 55
    OR_ASSIGN       shift and go to state 56
    XOR_ASSIGN      shift and go to state 57
    MOD_ASSIGN      shift and go to state 58
    L_SHIFT_ASSIGN  shift and go to state 59
    R_SHIFT_ASSIGN  shift and go to state 60

    assignment                     shift and go to state 49

state 161

    (33) yes_dec_params -> yes_dec_params TYPE COMMA .

    TYPE            reduce using rule 33 (yes_dec_params -> yes_dec_params TYPE COMMA .)


state 162

    (34) yes_dec_params -> yes_dec_params TYPE MULTIPLY . COMMA

    COMMA           shift and go to state 164


state 163

    (32) yes_dec_params -> yes_dec_params TYPE expr COMMA .

    TYPE            reduce using rule 32 (yes_dec_params -> yes_dec_params TYPE expr COMMA .)


state 164

    (34) yes_dec_params -> yes_dec_params TYPE MULTIPLY COMMA .

    TYPE            reduce using rule 34 (yes_dec_params -> yes_dec_params TYPE MULTIPLY COMMA .)

